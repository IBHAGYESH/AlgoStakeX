/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from '@algorandfoundation/algokit-utils/types/algorand-client'
import { ABIReturn, AppReturn, SendAppTransactionResult } from '@algorandfoundation/algokit-utils/types/app'
import { Arc56Contract, getArc56ReturnValue, getABIStructFromABITuple } from '@algorandfoundation/algokit-utils/types/app-arc56'
import {
  AppClient as _AppClient,
  AppClientMethodCallParams,
  AppClientParams,
  AppClientBareCallParams,
  CallOnComplete,
  AppClientCompilationParams,
  ResolveAppClientByCreatorAndName,
  ResolveAppClientByNetwork,
  CloneAppClientParams,
} from '@algorandfoundation/algokit-utils/types/app-client'
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory'
import { TransactionComposer, AppCallMethodCall, AppMethodCallTransactionArgument, SimulateOptions, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer'
import { SendParams, SendSingleTransactionResult, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction'
import { Address, encodeAddress, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk'

export const APP_SPEC: Arc56Contract = {"name":"AlgoStakeX","structs":{"StakeData":[{"name":"staker","type":"address"},{"name":"tokenId","type":"uint64"},{"name":"isFlexible","type":"bool"},{"name":"amount","type":"uint64"},{"name":"stakedAt","type":"uint64"},{"name":"lockPeriod","type":"uint64"},{"name":"lockEndTime","type":"uint64"},{"name":"rewardType","type":"string"},{"name":"rewardRate","type":"uint64"},{"name":"utility","type":"string"}]},"methods":[{"name":"stake","args":[{"type":"string","name":"poolId"},{"type":"uint64","name":"tokenId"},{"type":"bool","name":"isFlexible"},{"type":"uint64","name":"amount"},{"type":"uint64","name":"lockPeriod"},{"type":"string","name":"rewardType"},{"type":"uint64","name":"rewardRate"},{"type":"string","name":"utility"}],"returns":{"type":"byte[]"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Stake tokens into a pool\nTransaction group expected:\n[0] App call: stake\n[1] Asset transfer: User → Contract","events":[],"recommendations":{}},{"name":"withdraw","args":[{"type":"string","name":"poolId"}],"returns":{"type":"byte[]"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Withdraw staked tokens with rewards","events":[],"recommendations":{}},{"name":"emergencyWithdraw","args":[{"type":"string","name":"poolId"},{"type":"uint64","name":"penaltyPercentage"},{"type":"address","name":"treasuryAddress"}],"returns":{"type":"byte[]"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Emergency withdraw with penalty (for locked staking)\nPenalty tokens are sent to treasury wallet for recycling","events":[],"recommendations":{}},{"name":"hasValidStake","args":[{"type":"string","name":"poolId"},{"type":"string","name":"userAddress"},{"type":"uint64","name":"minimumAmount"}],"returns":{"type":"bool"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Check if user has valid stake (for access control)","events":[],"recommendations":{}},{"name":"getStakeInfo","args":[{"type":"string","name":"poolId"},{"type":"string","name":"userAddress"}],"returns":{"type":"(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)","struct":"StakeData"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Get stake information for a user","events":[],"recommendations":{}},{"name":"donateTokens","args":[{"type":"uint64","name":"tokenId"},{"type":"uint64","name":"amount"}],"returns":{"type":"byte[]"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Donate tokens to contract (no staking)\nTransaction group:\n[0] App call: donateTokens\n[1] Asset transfer: User → Contract","events":[],"recommendations":{}},{"name":"withdrawExcessTokens","args":[{"type":"uint64","name":"tokenId"},{"type":"uint64","name":"amount"}],"returns":{"type":"byte[]"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Withdraw excess tokens from contract (admin only)\nOnly withdraws tokens that are NOT currently staked","events":[],"recommendations":{}},{"name":"fundContract","args":[{"type":"uint64","name":"amount"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Fund contract with ALGO for MBR","events":[],"recommendations":{}},{"name":"withdrawExcessAlgo","args":[],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Withdraw excess ALGO from contract","events":[],"recommendations":{}}],"arcs":[22,28],"networks":{},"state":{"schema":{"global":{"ints":0,"bytes":0},"local":{"ints":0,"bytes":0}},"keys":{"global":{},"local":{},"box":{}},"maps":{"global":{},"local":{},"box":{"stakes":{"keyType":"AVMBytes","valueType":"StakeData","prefix":"c3Rha2Vf"}}}},"bareActions":{"create":["NoOp"],"call":[]},"sourceInfo":{"approval":{"sourceInfo":[{"pc":[513],"errorMessage":"Lock period not ended"},{"pc":[471,605],"errorMessage":"No active stake found"},{"pc":[972],"errorMessage":"No excess balance to withdraw"},{"pc":[825],"errorMessage":"No stake found"},{"pc":[481,615],"errorMessage":"Not the staker"},{"pc":[43],"errorMessage":"OnCompletion must be NoOp"},{"pc":[125],"errorMessage":"OnCompletion must be NoOp && can only call when creating"},{"pc":[938],"errorMessage":"Only admin can fund the contract"},{"pc":[899],"errorMessage":"Only admin can withdraw excess"},{"pc":[960],"errorMessage":"Only admin can withdraw funds"},{"pc":[965],"errorMessage":"account funded"},{"pc":[133,199,235,450,561,705,718,792,805],"errorMessage":"invalid array length header"},{"pc":[162],"errorMessage":"invalid number of bytes for arc4.bool"},{"pc":[140,209,241,457,568,712,725,799,812],"errorMessage":"invalid number of bytes for arc4.dynamic_array<arc4.uint8>"},{"pc":[588],"errorMessage":"invalid number of bytes for arc4.static_array<arc4.uint8, 32>"},{"pc":[151,173,187,223,576,733,842,850,883,892,931],"errorMessage":"invalid number of bytes for arc4.uint64"},{"pc":[286],"errorMessage":"rewardRate must be 0 when rewardType is not APY"}],"pcOffsetMethod":"none"},"clear":{"sourceInfo":[],"pcOffsetMethod":"none"}},"source":{"approval":"I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCA4IDEgMgogICAgYnl0ZWNibG9jayAweDAwMDE1ZiAic3Rha2VfIiAweDE1MWY3Yzc1MDAyMCAweDAwNTUgMHgxNTFmN2M3NQogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czozNgogICAgLy8gZXhwb3J0IGNsYXNzIEFsZ29TdGFrZVggZXh0ZW5kcyBDb250cmFjdCB7CiAgICB0eG4gTnVtQXBwQXJncwogICAgYnogbWFpbl9fX2FsZ290c19fLmRlZmF1bHRDcmVhdGVAMTYKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gbXVzdCBiZSBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0CiAgICBwdXNoYnl0ZXNzIDB4YTUwODIxMTkgMHhmNWQ4YTM0YiAweGVhMDBiZmZmIDB4OTFhZTI5MWUgMHhlZjcyM2M4ZCAweDhkOGZkYWMyIDB4NzcyYjU1NzQgMHg1NWQ5NTI1YiAweDMwNjc2OTc4IC8vIG1ldGhvZCAic3Rha2Uoc3RyaW5nLHVpbnQ2NCxib29sLHVpbnQ2NCx1aW50NjQsc3RyaW5nLHVpbnQ2NCxzdHJpbmcpYnl0ZVtdIiwgbWV0aG9kICJ3aXRoZHJhdyhzdHJpbmcpYnl0ZVtdIiwgbWV0aG9kICJlbWVyZ2VuY3lXaXRoZHJhdyhzdHJpbmcsdWludDY0LGFkZHJlc3MpYnl0ZVtdIiwgbWV0aG9kICJoYXNWYWxpZFN0YWtlKHN0cmluZyxzdHJpbmcsdWludDY0KWJvb2wiLCBtZXRob2QgImdldFN0YWtlSW5mbyhzdHJpbmcsc3RyaW5nKShhZGRyZXNzLHVpbnQ2NCxib29sLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCxzdHJpbmcsdWludDY0LHN0cmluZykiLCBtZXRob2QgImRvbmF0ZVRva2Vucyh1aW50NjQsdWludDY0KWJ5dGVbXSIsIG1ldGhvZCAid2l0aGRyYXdFeGNlc3NUb2tlbnModWludDY0LHVpbnQ2NClieXRlW10iLCBtZXRob2QgImZ1bmRDb250cmFjdCh1aW50NjQpdm9pZCIsIG1ldGhvZCAid2l0aGRyYXdFeGNlc3NBbGdvKCl2b2lkIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggc3Rha2Ugd2l0aGRyYXcgZW1lcmdlbmN5V2l0aGRyYXcgaGFzVmFsaWRTdGFrZSBnZXRTdGFrZUluZm8gZG9uYXRlVG9rZW5zIHdpdGhkcmF3RXhjZXNzVG9rZW5zIGZ1bmRDb250cmFjdCB3aXRoZHJhd0V4Y2Vzc0FsZ28KICAgIGVycgoKbWFpbl9fX2FsZ290c19fLmRlZmF1bHRDcmVhdGVAMTY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjM2CiAgICAvLyBleHBvcnQgY2xhc3MgQWxnb1N0YWtlWCBleHRlbmRzIENvbnRyYWN0IHsKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAhCiAgICAmJgogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBtdXN0IGJlIE5vT3AgJiYgY2FuIG9ubHkgY2FsbCB3aGVuIGNyZWF0aW5nCiAgICBpbnRjXzIgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo6QWxnb1N0YWtlWC5zdGFrZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CnN0YWtlOgogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo0NgogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PGFyYzQudWludDg+CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgY292ZXIgMwogICAgbGVuCiAgICBpbnRjXzIgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5ib29sCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIGNvdmVyIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGR1cAogICAgY292ZXIgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgY292ZXIgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgogICAgZHVwCiAgICBjb3ZlciAzCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgZHVwCiAgICBjb3ZlciA1CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LmR5bmFtaWNfYXJyYXk8YXJjNC51aW50OD4KICAgIGV4dHJhY3QgMiAwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA3CiAgICBkdXAKICAgIGNvdmVyIDQKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIGNvdmVyIDMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDgKICAgIGR1cAogICAgY292ZXIgNAogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYgLy8gb24gZXJyb3I6IGludmFsaWQgYXJyYXkgbGVuZ3RoIGhlYWRlcgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIHN3YXAKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PGFyYzQudWludDg+CiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjYyCiAgICAvLyBvcC5jb25jYXQocG9vbElkQnl0ZXMsIHNlcGFyYXRvciksCiAgICB1bmNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6NjAKICAgIC8vIGNvbnN0IHNlcGFyYXRvciA9IG5ldyBhcmM0LlN0cigiXyIpLmJ5dGVzOwogICAgYnl0ZWNfMCAvLyAweDAwMDE1ZgogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo2MgogICAgLy8gb3AuY29uY2F0KHBvb2xJZEJ5dGVzLCBzZXBhcmF0b3IpLAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjYzCiAgICAvLyBUeG4uc2VuZGVyLmJ5dGVzCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjYxLTY0CiAgICAvLyBjb25zdCBzdGFrZUtleSA9IG9wLmNvbmNhdCgKICAgIC8vICAgb3AuY29uY2F0KHBvb2xJZEJ5dGVzLCBzZXBhcmF0b3IpLAogICAgLy8gICBUeG4uc2VuZGVyLmJ5dGVzCiAgICAvLyApOwogICAgY29uY2F0CiAgICBjb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjY3LTc0CiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICB4ZmVyQXNzZXQ6IHRva2VuSWQsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IDAsCiAgICAvLyAgICAgZmVlOiAwLAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCk7CiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjY5CiAgICAvLyBhc3NldFJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjcxCiAgICAvLyBhc3NldEFtb3VudDogMCwKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6NjctNzMKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIHhmZXJBc3NldDogdG9rZW5JZCwKICAgIC8vICAgICBhc3NldEFtb3VudDogMCwKICAgIC8vICAgICBmZWU6IDAsCiAgICAvLyAgIH0pCiAgICBwdXNoaW50IDQgLy8gNAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo3MgogICAgLy8gZmVlOiAwLAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjY3LTc0CiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICB4ZmVyQXNzZXQ6IHRva2VuSWQsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IDAsCiAgICAvLyAgICAgZmVlOiAwLAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCk7CiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo3NgogICAgLy8gY29uc3QgY3VycmVudFRpbWUgPSBHbG9iYWwubGF0ZXN0VGltZXN0YW1wOwogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo4MAogICAgLy8gaWYgKHJld2FyZFR5cGUgPT09ICJBUFkiKSB7CiAgICBwdXNoYnl0ZXMgIkFQWSIKICAgID09CiAgICBibnogc3Rha2VfYWZ0ZXJfaWZfZWxzZUA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjg1CiAgICAvLyByZXdhcmRSYXRlID09PSBVaW50NjQoMCksCiAgICBkaWcgMwogICAgIQogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo4NC04NwogICAgLy8gYXNzZXJ0KAogICAgLy8gICByZXdhcmRSYXRlID09PSBVaW50NjQoMCksCiAgICAvLyAgICJyZXdhcmRSYXRlIG11c3QgYmUgMCB3aGVuIHJld2FyZFR5cGUgaXMgbm90IEFQWSIKICAgIC8vICk7CiAgICBhc3NlcnQgLy8gcmV3YXJkUmF0ZSBtdXN0IGJlIDAgd2hlbiByZXdhcmRUeXBlIGlzIG5vdCBBUFkKCnN0YWtlX2FmdGVyX2lmX2Vsc2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MzgKICAgIC8vIHByaXZhdGUgc3Rha2VzID0gQm94TWFwPGJ5dGVzLCBTdGFrZURhdGE+KHsga2V5UHJlZml4OiAic3Rha2VfIiB9KTsKICAgIGJ5dGVjXzEgLy8gInN0YWtlXyIKICAgIGRpZyAyCiAgICBjb25jYXQKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo5MQogICAgLy8gaWYgKHRoaXMuc3Rha2VzKHN0YWtlS2V5KS5leGlzdHMpIHsKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYnogc3Rha2VfZWxzZV9ib2R5QDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6OTcKICAgIC8vIHN0YWtlcjogbmV3IGFyYzQuQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6OTgKICAgIC8vIHRva2VuSWQ6IG5ldyBhcmM0LlVpbnQ2NChleGlzdGluZ1N0YWtlLnRva2VuSWQuYXNVaW50NjQoKSksIC8vIGtlZXAgb3JpZ2luYWwgdG9rZW4gaWQKICAgIHN3YXAKICAgIGR1cAogICAgcHVzaGludCAzMiAvLyAzMgogICAgaW50Y18xIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjEwMQogICAgLy8gVWludDY0KGV4aXN0aW5nU3Rha2UuYW1vdW50LmFzVWludDY0KCkgKyBhbW91bnQpCiAgICBkaWcgMQogICAgcHVzaGludCA0MSAvLyA0MQogICAgaW50Y18xIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBkaWcgMTMKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MTAwLTEwMgogICAgLy8gYW1vdW50OiBuZXcgYXJjNC5VaW50NjQoCiAgICAvLyAgIFVpbnQ2NChleGlzdGluZ1N0YWtlLmFtb3VudC5hc1VpbnQ2NCgpICsgYW1vdW50KQogICAgLy8gKSwgLy8gY3VycmVudCBhbW91bnQgKyBuZXcgYW1vdW50CiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjEwMwogICAgLy8gc3Rha2VkQXQ6IG5ldyBhcmM0LlVpbnQ2NChleGlzdGluZ1N0YWtlLnN0YWtlZEF0LmFzVWludDY0KCkpLCAvLyBLZWVwIG9yaWdpbmFsIHRpbWUKICAgIGRpZyAyCiAgICBwdXNoaW50IDQ5IC8vIDQ5CiAgICBpbnRjXzEgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MTA1CiAgICAvLyBsb2NrRW5kVGltZTogbmV3IGFyYzQuVWludDY0KFVpbnQ2NChjdXJyZW50VGltZSArIGxvY2tQZXJpb2QpKSwgLy8gY3VycmVudCBsb2NrIGVuZCB0aW1lCiAgICBkaWcgNQogICAgZGlnIDEzCiAgICArCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjk2LTEwOQogICAgLy8gY29uc3QgdXBkYXRlZFN0YWtlID0gbmV3IFN0YWtlRGF0YSh7CiAgICAvLyAgIHN0YWtlcjogbmV3IGFyYzQuQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIC8vICAgdG9rZW5JZDogbmV3IGFyYzQuVWludDY0KGV4aXN0aW5nU3Rha2UudG9rZW5JZC5hc1VpbnQ2NCgpKSwgLy8ga2VlcCBvcmlnaW5hbCB0b2tlbiBpZAogICAgLy8gICBpc0ZsZXhpYmxlOiBuZXcgYXJjNC5Cb29sKGlzRmxleGlibGUpLCAvLyBjdXJyZW50IHN0YWtpbmcgdHlwZQogICAgLy8gICBhbW91bnQ6IG5ldyBhcmM0LlVpbnQ2NCgKICAgIC8vICAgICBVaW50NjQoZXhpc3RpbmdTdGFrZS5hbW91bnQuYXNVaW50NjQoKSArIGFtb3VudCkKICAgIC8vICAgKSwgLy8gY3VycmVudCBhbW91bnQgKyBuZXcgYW1vdW50CiAgICAvLyAgIHN0YWtlZEF0OiBuZXcgYXJjNC5VaW50NjQoZXhpc3RpbmdTdGFrZS5zdGFrZWRBdC5hc1VpbnQ2NCgpKSwgLy8gS2VlcCBvcmlnaW5hbCB0aW1lCiAgICAvLyAgIGxvY2tQZXJpb2Q6IG5ldyBhcmM0LlVpbnQ2NChsb2NrUGVyaW9kKSwgLy8gY3VycmVudCBsb2NrIHBlcmlvZAogICAgLy8gICBsb2NrRW5kVGltZTogbmV3IGFyYzQuVWludDY0KFVpbnQ2NChjdXJyZW50VGltZSArIGxvY2tQZXJpb2QpKSwgLy8gY3VycmVudCBsb2NrIGVuZCB0aW1lCiAgICAvLyAgIHJld2FyZFR5cGU6IG5ldyBhcmM0LlN0cihyZXdhcmRUeXBlKSwgLy8gY3VycmVudCByZXdhcmQgdHlwZQogICAgLy8gICByZXdhcmRSYXRlOiBuZXcgYXJjNC5VaW50NjQocmV3YXJkUmF0ZSksIC8vIGN1cnJlbnQgcmV3YXJkIHJhdGUKICAgIC8vICAgdXRpbGl0eTogbmV3IGFyYzQuU3RyKHV0aWxpdHkpLCAvLyBjdXJyZW50IHV0aWxpdHkKICAgIC8vIH0pOwogICAgdW5jb3ZlciA1CiAgICB1bmNvdmVyIDQKICAgIGNvbmNhdAogICAgZGlnIDE2CiAgICBjb25jYXQKICAgIHVuY292ZXIgMwogICAgY29uY2F0CiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgZGlnIDExCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYnl0ZWNfMyAvLyAweDAwNTUKICAgIGNvbmNhdAogICAgcHVzaGludCA4NSAvLyA4NQogICAgZGlnIDgKICAgICsKICAgIHN3YXAKICAgIGRpZyA3CiAgICBjb25jYXQKICAgIHN3YXAKICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBjb25jYXQKICAgIGRpZyA4CiAgICBjb25jYXQKICAgIGRpZyA0CiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MTExCiAgICAvLyB0aGlzLnN0YWtlcyhzdGFrZUtleSkudmFsdWUgPSBjbG9uZSh1cGRhdGVkU3Rha2UpOwogICAgZGlnIDEKICAgIGJveF9kZWwKICAgIHBvcAogICAgYm94X3B1dAoKc3Rha2VfYWZ0ZXJfaWZfZWxzZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo0NgogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBieXRlY18yIC8vIDB4MTUxZjdjNzUwMDIwCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjEzMAogICAgLy8gcmV0dXJuIFR4bi50eElkOwogICAgdHhuIFR4SUQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6NDYKICAgIC8vIEBhYmltZXRob2QoKQogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCnN0YWtlX2Vsc2VfYm9keUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoxMTUKICAgIC8vIHN0YWtlcjogbmV3IGFyYzQuQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MTE5CiAgICAvLyBzdGFrZWRBdDogbmV3IGFyYzQuVWludDY0KGN1cnJlbnRUaW1lKSwKICAgIGRpZyAyCiAgICBkdXAKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MTIxCiAgICAvLyBsb2NrRW5kVGltZTogbmV3IGFyYzQuVWludDY0KFVpbnQ2NChjdXJyZW50VGltZSArIGxvY2tQZXJpb2QpKSwKICAgIHN3YXAKICAgIGRpZyAxMQogICAgKwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoxMTQtMTI1CiAgICAvLyBjb25zdCBuZXdTdGFrZSA9IG5ldyBTdGFrZURhdGEoewogICAgLy8gICBzdGFrZXI6IG5ldyBhcmM0LkFkZHJlc3MoVHhuLnNlbmRlciksCiAgICAvLyAgIHRva2VuSWQ6IG5ldyBhcmM0LlVpbnQ2NCh0b2tlbklkKSwKICAgIC8vICAgaXNGbGV4aWJsZTogbmV3IGFyYzQuQm9vbChpc0ZsZXhpYmxlKSwKICAgIC8vICAgYW1vdW50OiBuZXcgYXJjNC5VaW50NjQoYW1vdW50KSwKICAgIC8vICAgc3Rha2VkQXQ6IG5ldyBhcmM0LlVpbnQ2NChjdXJyZW50VGltZSksCiAgICAvLyAgIGxvY2tQZXJpb2Q6IG5ldyBhcmM0LlVpbnQ2NChsb2NrUGVyaW9kKSwKICAgIC8vICAgbG9ja0VuZFRpbWU6IG5ldyBhcmM0LlVpbnQ2NChVaW50NjQoY3VycmVudFRpbWUgKyBsb2NrUGVyaW9kKSksCiAgICAvLyAgIHJld2FyZFR5cGU6IG5ldyBhcmM0LlN0cihyZXdhcmRUeXBlKSwKICAgIC8vICAgcmV3YXJkUmF0ZTogbmV3IGFyYzQuVWludDY0KHJld2FyZFJhdGUpLAogICAgLy8gICB1dGlsaXR5OiBuZXcgYXJjNC5TdHIodXRpbGl0eSksCiAgICAvLyB9KTsKICAgIHVuY292ZXIgMgogICAgZGlnIDE2CiAgICBjb25jYXQKICAgIGRpZyAxNQogICAgY29uY2F0CiAgICBkaWcgMTQKICAgIGNvbmNhdAogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIGRpZyAxMQogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjXzMgLy8gMHgwMDU1CiAgICBjb25jYXQKICAgIHB1c2hpbnQgODUgLy8gODUKICAgIGRpZyA4CiAgICArCiAgICBzd2FwCiAgICBkaWcgNwogICAgY29uY2F0CiAgICBzd2FwCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgY29uY2F0CiAgICBkaWcgOAogICAgY29uY2F0CiAgICBkaWcgNAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjEyNwogICAgLy8gdGhpcy5zdGFrZXMoc3Rha2VLZXkpLnZhbHVlID0gY2xvbmUobmV3U3Rha2UpOwogICAgc3dhcAogICAgZHVwCiAgICBib3hfZGVsCiAgICBwb3AKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIGIgc3Rha2VfYWZ0ZXJfaWZfZWxzZUA4CgoKLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo6QWxnb1N0YWtlWC53aXRoZHJhd1tyb3V0aW5nXSgpIC0+IHZvaWQ6CndpdGhkcmF3OgogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoxMzYKICAgIC8vIEBhYmltZXRob2QoKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYgLy8gb24gZXJyb3I6IGludmFsaWQgYXJyYXkgbGVuZ3RoIGhlYWRlcgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuZHluYW1pY19hcnJheTxhcmM0LnVpbnQ4PgogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoxNDAKICAgIC8vIGNvbnN0IHNlcGFyYXRvciA9IG5ldyBhcmM0LlN0cigiXyIpLmJ5dGVzOwogICAgYnl0ZWNfMCAvLyAweDAwMDE1ZgogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoxNDIKICAgIC8vIG9wLmNvbmNhdChwb29sSWRCeXRlcywgc2VwYXJhdG9yKSwKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoxNDMKICAgIC8vIFR4bi5zZW5kZXIuYnl0ZXMKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MTQxLTE0NAogICAgLy8gY29uc3Qgc3Rha2VLZXkgPSBvcC5jb25jYXQoCiAgICAvLyAgIG9wLmNvbmNhdChwb29sSWRCeXRlcywgc2VwYXJhdG9yKSwKICAgIC8vICAgVHhuLnNlbmRlci5ieXRlcwogICAgLy8gKTsKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czozOAogICAgLy8gcHJpdmF0ZSBzdGFrZXMgPSBCb3hNYXA8Ynl0ZXMsIFN0YWtlRGF0YT4oeyBrZXlQcmVmaXg6ICJzdGFrZV8iIH0pOwogICAgYnl0ZWNfMSAvLyAic3Rha2VfIgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXBuIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MTQ3CiAgICAvLyBhc3NlcnQodGhpcy5zdGFrZXMoc3Rha2VLZXkpLmV4aXN0cywgIk5vIGFjdGl2ZSBzdGFrZSBmb3VuZCIpOwogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gTm8gYWN0aXZlIHN0YWtlIGZvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjE1MgogICAgLy8gY29uc3QgY3VycmVudFNlbmRlckFkZHIgPSBuZXcgYXJjNC5BZGRyZXNzKFR4bi5zZW5kZXIpOwogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoxNTQKICAgIC8vIHN0YWtlRGF0YS5zdGFrZXIubmF0aXZlID09PSBjdXJyZW50U2VuZGVyQWRkci5uYXRpdmUsCiAgICBkaWcgMQogICAgaW50Y18wIC8vIDAKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGJveF9leHRyYWN0CiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoxNTMtMTU2CiAgICAvLyBhc3NlcnQoCiAgICAvLyAgIHN0YWtlRGF0YS5zdGFrZXIubmF0aXZlID09PSBjdXJyZW50U2VuZGVyQWRkci5uYXRpdmUsCiAgICAvLyAgICJOb3QgdGhlIHN0YWtlciIKICAgIC8vICk7CiAgICBhc3NlcnQgLy8gTm90IHRoZSBzdGFrZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MTU4CiAgICAvLyBjb25zdCBjdXJyZW50VGltZSA9IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXA7CiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjE2MQogICAgLy8gaWYgKCFzdGFrZURhdGEuaXNGbGV4aWJsZS5uYXRpdmUpIHsKICAgIHB1c2hpbnQgNDAgLy8gNDAKICAgIGludGNfMiAvLyAxCiAgICBib3hfZXh0cmFjdAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgcHVzaGJ5dGVzIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgYm56IHdpdGhkcmF3X2FmdGVyX2lmX2Vsc2VAMwogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoxNjMKICAgIC8vIGN1cnJlbnRUaW1lID49IHN0YWtlRGF0YS5sb2NrRW5kVGltZS5hc1VpbnQ2NCgpLAogICAgZGlnIDEKICAgIHB1c2hpbnQgNjUgLy8gNjUKICAgIGludGNfMSAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgZGlnIDEKICAgIDw9CiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjE2Mi0xNjUKICAgIC8vIGFzc2VydCgKICAgIC8vICAgY3VycmVudFRpbWUgPj0gc3Rha2VEYXRhLmxvY2tFbmRUaW1lLmFzVWludDY0KCksCiAgICAvLyAgICJMb2NrIHBlcmlvZCBub3QgZW5kZWQiCiAgICAvLyApOwogICAgYXNzZXJ0IC8vIExvY2sgcGVyaW9kIG5vdCBlbmRlZAoKd2l0aGRyYXdfYWZ0ZXJfaWZfZWxzZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoxNjktMTc2CiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBUeG4uc2VuZGVyLAogICAgLy8gICAgIHhmZXJBc3NldDogc3Rha2VEYXRhLnRva2VuSWQuYXNVaW50NjQoKSwKICAgIC8vICAgICBhc3NldEFtb3VudDogc3Rha2VEYXRhLmFtb3VudC5hc1VpbnQ2NCgpLAogICAgLy8gICAgIGZlZTogMCwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpOwogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoxNzEKICAgIC8vIGFzc2V0UmVjZWl2ZXI6IFR4bi5zZW5kZXIsCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjE3MgogICAgLy8geGZlckFzc2V0OiBzdGFrZURhdGEudG9rZW5JZC5hc1VpbnQ2NCgpLAogICAgZGlnIDIKICAgIGR1cAogICAgcHVzaGludCAzMiAvLyAzMgogICAgaW50Y18xIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjE3MwogICAgLy8gYXNzZXRBbW91bnQ6IHN0YWtlRGF0YS5hbW91bnQuYXNVaW50NjQoKSwKICAgIGRpZyAxCiAgICBwdXNoaW50IDQxIC8vIDQxCiAgICBpbnRjXzEgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MTY5LTE3NQogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogVHhuLnNlbmRlciwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IHN0YWtlRGF0YS50b2tlbklkLmFzVWludDY0KCksCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IHN0YWtlRGF0YS5hbW91bnQuYXNVaW50NjQoKSwKICAgIC8vICAgICBmZWU6IDAsCiAgICAvLyAgIH0pCiAgICBwdXNoaW50IDQgLy8gNAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoxNzQKICAgIC8vIGZlZTogMCwKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoxNjktMTc2CiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBUeG4uc2VuZGVyLAogICAgLy8gICAgIHhmZXJBc3NldDogc3Rha2VEYXRhLnRva2VuSWQuYXNVaW50NjQoKSwKICAgIC8vICAgICBhc3NldEFtb3VudDogc3Rha2VEYXRhLmFtb3VudC5hc1VpbnQ2NCgpLAogICAgLy8gICAgIGZlZTogMCwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpOwogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MTgyCiAgICAvLyB0aGlzLnN0YWtlcyhzdGFrZUtleSkuZGVsZXRlKCk7CiAgICBib3hfZGVsCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MTM2CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGJ5dGVjXzIgLy8gMHgxNTFmN2M3NTAwMjAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MTg0CiAgICAvLyByZXR1cm4gVHhuLnR4SWQ7CiAgICB0eG4gVHhJRAogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoxMzYKICAgIC8vIEBhYmltZXRob2QoKQogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjpBbGdvU3Rha2VYLmVtZXJnZW5jeVdpdGhkcmF3W3JvdXRpbmddKCkgLT4gdm9pZDoKZW1lcmdlbmN5V2l0aGRyYXc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjE5MQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PGFyYzQudWludDg+CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5zdGF0aWNfYXJyYXk8YXJjNC51aW50OCwgMzI+CiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjIwMAogICAgLy8gb3AuY29uY2F0KHBvb2xJZEJ5dGVzLCBzZXBhcmF0b3IpLAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoxOTgKICAgIC8vIGNvbnN0IHNlcGFyYXRvciA9IG5ldyBhcmM0LlN0cigiXyIpLmJ5dGVzOwogICAgYnl0ZWNfMCAvLyAweDAwMDE1ZgogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoyMDAKICAgIC8vIG9wLmNvbmNhdChwb29sSWRCeXRlcywgc2VwYXJhdG9yKSwKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoyMDEKICAgIC8vIFR4bi5zZW5kZXIuYnl0ZXMKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MTk5LTIwMgogICAgLy8gY29uc3Qgc3Rha2VLZXkgPSBvcC5jb25jYXQoCiAgICAvLyAgIG9wLmNvbmNhdChwb29sSWRCeXRlcywgc2VwYXJhdG9yKSwKICAgIC8vICAgVHhuLnNlbmRlci5ieXRlcwogICAgLy8gKTsKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czozOAogICAgLy8gcHJpdmF0ZSBzdGFrZXMgPSBCb3hNYXA8Ynl0ZXMsIFN0YWtlRGF0YT4oeyBrZXlQcmVmaXg6ICJzdGFrZV8iIH0pOwogICAgYnl0ZWNfMSAvLyAic3Rha2VfIgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MjA0CiAgICAvLyBhc3NlcnQodGhpcy5zdGFrZXMoc3Rha2VLZXkpLmV4aXN0cywgIk5vIGFjdGl2ZSBzdGFrZSBmb3VuZCIpOwogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBObyBhY3RpdmUgc3Rha2UgZm91bmQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MjA4CiAgICAvLyBjb25zdCBjdXJyZW50U2VuZGVyQWRkciA9IG5ldyBhcmM0LkFkZHJlc3MoVHhuLnNlbmRlcik7CiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjIxMAogICAgLy8gc3Rha2VEYXRhLnN0YWtlci5uYXRpdmUgPT09IGN1cnJlbnRTZW5kZXJBZGRyLm5hdGl2ZSwKICAgIGRpZyAxCiAgICBpbnRjXzAgLy8gMAogICAgcHVzaGludCAzMiAvLyAzMgogICAgYm94X2V4dHJhY3QKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjIwOS0yMTIKICAgIC8vIGFzc2VydCgKICAgIC8vICAgc3Rha2VEYXRhLnN0YWtlci5uYXRpdmUgPT09IGN1cnJlbnRTZW5kZXJBZGRyLm5hdGl2ZSwKICAgIC8vICAgIk5vdCB0aGUgc3Rha2VyIgogICAgLy8gKTsKICAgIGFzc2VydCAvLyBOb3QgdGhlIHN0YWtlcgogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoyMTYKICAgIC8vIChzdGFrZURhdGEuYW1vdW50LmFzVWludDY0KCkgKiBwZW5hbHR5UGVyY2VudGFnZSkgLyBCQVNJU19QT0lOVFNfRElWSVNPUgogICAgZHVwCiAgICBwdXNoaW50IDQxIC8vIDQxCiAgICBpbnRjXzEgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGR1cAogICAgdW5jb3ZlciAzCiAgICAqCiAgICBwdXNoaW50IDEwMDAwIC8vIDEwMDAwCiAgICAvCiAgICBkdXAKICAgIGNvdmVyIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MjE4CiAgICAvLyBjb25zdCBhbW91bnRUb1JldHVybiA9IFVpbnQ2NChzdGFrZURhdGEuYW1vdW50LmFzVWludDY0KCkgLSBwZW5hbHR5KTsKICAgIHN3YXAKICAgIGRpZyAxCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjIyMS0yMjgKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IFR4bi5zZW5kZXIsCiAgICAvLyAgICAgeGZlckFzc2V0OiBzdGFrZURhdGEudG9rZW5JZC5hc1VpbnQ2NCgpLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiBhbW91bnRUb1JldHVybiwKICAgIC8vICAgICBmZWU6IDAsCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKTsKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MjIzCiAgICAvLyBhc3NldFJlY2VpdmVyOiBUeG4uc2VuZGVyLAogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoyMjQKICAgIC8vIHhmZXJBc3NldDogc3Rha2VEYXRhLnRva2VuSWQuYXNVaW50NjQoKSwKICAgIHVuY292ZXIgMwogICAgcHVzaGludCAzMiAvLyAzMgogICAgaW50Y18xIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDQKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoyMjEtMjI3CiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBUeG4uc2VuZGVyLAogICAgLy8gICAgIHhmZXJBc3NldDogc3Rha2VEYXRhLnRva2VuSWQuYXNVaW50NjQoKSwKICAgIC8vICAgICBhc3NldEFtb3VudDogYW1vdW50VG9SZXR1cm4sCiAgICAvLyAgICAgZmVlOiAwLAogICAgLy8gICB9KQogICAgcHVzaGludCA0IC8vIDQKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MjI2CiAgICAvLyBmZWU6IDAsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MjIxLTIyOAogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogVHhuLnNlbmRlciwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IHN0YWtlRGF0YS50b2tlbklkLmFzVWludDY0KCksCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IGFtb3VudFRvUmV0dXJuLAogICAgLy8gICAgIGZlZTogMCwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpOwogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MjMxCiAgICAvLyBpZiAocGVuYWx0eSA+IDApIHsKICAgIGJ6IGVtZXJnZW5jeVdpdGhkcmF3X2FmdGVyX2lmX2Vsc2VANQogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoyMzItMjM5CiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiB0cmVhc3VyeUFkZHJlc3MubmF0aXZlLAogICAgLy8gICAgIHhmZXJBc3NldDogc3Rha2VEYXRhLnRva2VuSWQuYXNVaW50NjQoKSwKICAgIC8vICAgICBhc3NldEFtb3VudDogcGVuYWx0eSwKICAgIC8vICAgICBmZWU6IDAsCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKTsKICAgIGl0eG5fYmVnaW4KICAgIGRpZyAxCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBkdXAKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICBkaWcgMwogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjIzMi0yMzgKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IHRyZWFzdXJ5QWRkcmVzcy5uYXRpdmUsCiAgICAvLyAgICAgeGZlckFzc2V0OiBzdGFrZURhdGEudG9rZW5JZC5hc1VpbnQ2NCgpLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiBwZW5hbHR5LAogICAgLy8gICAgIGZlZTogMCwKICAgIC8vICAgfSkKICAgIHB1c2hpbnQgNCAvLyA0CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjIzNwogICAgLy8gZmVlOiAwLAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjIzMi0yMzkKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IHRyZWFzdXJ5QWRkcmVzcy5uYXRpdmUsCiAgICAvLyAgICAgeGZlckFzc2V0OiBzdGFrZURhdGEudG9rZW5JZC5hc1VpbnQ2NCgpLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiBwZW5hbHR5LAogICAgLy8gICAgIGZlZTogMCwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpOwogICAgaXR4bl9zdWJtaXQKCmVtZXJnZW5jeVdpdGhkcmF3X2FmdGVyX2lmX2Vsc2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MjQzCiAgICAvLyB0aGlzLnN0YWtlcyhzdGFrZUtleSkuZGVsZXRlKCk7CiAgICBkaWcgMgogICAgYm94X2RlbAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjE5MQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBieXRlY18yIC8vIDB4MTUxZjdjNzUwMDIwCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjI0NQogICAgLy8gcmV0dXJuIFR4bi50eElkOwogICAgdHhuIFR4SUQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MTkxCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzIgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo6QWxnb1N0YWtlWC5oYXNWYWxpZFN0YWtlW3JvdXRpbmddKCkgLT4gdm9pZDoKaGFzVmFsaWRTdGFrZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MjUxCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2IC8vIG9uIGVycm9yOiBpbnZhbGlkIGFycmF5IGxlbmd0aCBoZWFkZXIKICAgIGludGNfMyAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LmR5bmFtaWNfYXJyYXk8YXJjNC51aW50OD4KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2IC8vIG9uIGVycm9yOiBpbnZhbGlkIGFycmF5IGxlbmd0aCBoZWFkZXIKICAgIGludGNfMyAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LmR5bmFtaWNfYXJyYXk8YXJjNC51aW50OD4KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MjYyCiAgICAvLyBvcC5jb25jYXQocG9vbElkQnl0ZXMsIHNlcGFyYXRvciksCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjI1OQogICAgLy8gY29uc3Qgc2VwYXJhdG9yID0gbmV3IGFyYzQuU3RyKCJfIikuYnl0ZXM7CiAgICBieXRlY18wIC8vIDB4MDAwMTVmCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjI2MgogICAgLy8gb3AuY29uY2F0KHBvb2xJZEJ5dGVzLCBzZXBhcmF0b3IpLAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjI2MS0yNjQKICAgIC8vIGNvbnN0IHN0YWtlS2V5ID0gb3AuY29uY2F0KAogICAgLy8gICBvcC5jb25jYXQocG9vbElkQnl0ZXMsIHNlcGFyYXRvciksCiAgICAvLyAgIHVzZXJBZGRyQnl0ZXMKICAgIC8vICk7CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MzgKICAgIC8vIHByaXZhdGUgc3Rha2VzID0gQm94TWFwPGJ5dGVzLCBTdGFrZURhdGE+KHsga2V5UHJlZml4OiAic3Rha2VfIiB9KTsKICAgIGJ5dGVjXzEgLy8gInN0YWtlXyIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjI2NgogICAgLy8gaWYgKCF0aGlzLnN0YWtlcyhzdGFrZUtleSkuZXhpc3RzKSB7CiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGJueiBoYXNWYWxpZFN0YWtlX2FmdGVyX2lmX2Vsc2VAMwogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoyNjcKICAgIC8vIHJldHVybiBmYWxzZTsKICAgIGludGNfMCAvLyAwCgpoYXNWYWxpZFN0YWtlX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo6QWxnb1N0YWtlWC5oYXNWYWxpZFN0YWtlQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjI1MQogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICBwdXNoYnl0ZXMgMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBieXRlYyA0IC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzIgLy8gMQogICAgcmV0dXJuCgpoYXNWYWxpZFN0YWtlX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MjczCiAgICAvLyBpZiAoc3Rha2VEYXRhLmFtb3VudC5hc1VpbnQ2NCgpIDwgbWluaW11bUFtb3VudCkgewogICAgZHVwCiAgICBwdXNoaW50IDQxIC8vIDQxCiAgICBpbnRjXzEgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGRpZyAyCiAgICA8CiAgICBieiBoYXNWYWxpZFN0YWtlX2FmdGVyX2lmX2Vsc2VANQogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoyNzQKICAgIC8vIHJldHVybiBmYWxzZTsKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjI1MQogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICBiIGhhc1ZhbGlkU3Rha2VfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjpBbGdvU3Rha2VYLmhhc1ZhbGlkU3Rha2VANgoKaGFzVmFsaWRTdGFrZV9hZnRlcl9pZl9lbHNlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjI3NwogICAgLy8gcmV0dXJuIHRydWU7CiAgICBpbnRjXzIgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoyNTEKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgYiBoYXNWYWxpZFN0YWtlX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo6QWxnb1N0YWtlWC5oYXNWYWxpZFN0YWtlQDYKCgovLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjpBbGdvU3Rha2VYLmdldFN0YWtlSW5mb1tyb3V0aW5nXSgpIC0+IHZvaWQ6CmdldFN0YWtlSW5mbzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MjgzCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2IC8vIG9uIGVycm9yOiBpbnZhbGlkIGFycmF5IGxlbmd0aCBoZWFkZXIKICAgIGludGNfMyAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LmR5bmFtaWNfYXJyYXk8YXJjNC51aW50OD4KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2IC8vIG9uIGVycm9yOiBpbnZhbGlkIGFycmF5IGxlbmd0aCBoZWFkZXIKICAgIGludGNfMyAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LmR5bmFtaWNfYXJyYXk8YXJjNC51aW50OD4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6Mjg5CiAgICAvLyBvcC5jb25jYXQocG9vbElkQnl0ZXMsIHNlcGFyYXRvciksCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjI4NgogICAgLy8gY29uc3Qgc2VwYXJhdG9yID0gbmV3IGFyYzQuU3RyKCJfIikuYnl0ZXM7CiAgICBieXRlY18wIC8vIDB4MDAwMTVmCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjI4OQogICAgLy8gb3AuY29uY2F0KHBvb2xJZEJ5dGVzLCBzZXBhcmF0b3IpLAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjI4OC0yOTEKICAgIC8vIGNvbnN0IHN0YWtlS2V5ID0gb3AuY29uY2F0KAogICAgLy8gICBvcC5jb25jYXQocG9vbElkQnl0ZXMsIHNlcGFyYXRvciksCiAgICAvLyAgIHVzZXJBZGRyQnl0ZXMKICAgIC8vICk7CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6MzgKICAgIC8vIHByaXZhdGUgc3Rha2VzID0gQm94TWFwPGJ5dGVzLCBTdGFrZURhdGE+KHsga2V5UHJlZml4OiAic3Rha2VfIiB9KTsKICAgIGJ5dGVjXzEgLy8gInN0YWtlXyIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoyOTMKICAgIC8vIGFzc2VydCh0aGlzLnN0YWtlcyhzdGFrZUtleSkuZXhpc3RzLCAiTm8gc3Rha2UgZm91bmQiKTsKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gTm8gc3Rha2UgZm91bmQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6Mjk1CiAgICAvLyByZXR1cm4gY2xvbmUodGhpcy5zdGFrZXMoc3Rha2VLZXkpLnZhbHVlKTsKICAgIGJveF9nZXQKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czoyODMKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgYnl0ZWMgNCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6OkFsZ29TdGFrZVguZG9uYXRlVG9rZW5zW3JvdXRpbmddKCkgLT4gdm9pZDoKZG9uYXRlVG9rZW5zOgogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo0MDAKICAgIC8vIEBhYmltZXRob2QoKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6NDAzLTQxMAogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgeGZlckFzc2V0OiB0b2tlbklkLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiAwLAogICAgLy8gICAgIGZlZTogMCwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpOwogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo0MDUKICAgIC8vIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6NDA3CiAgICAvLyBhc3NldEFtb3VudDogMCwKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjQwMy00MDkKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIHhmZXJBc3NldDogdG9rZW5JZCwKICAgIC8vICAgICBhc3NldEFtb3VudDogMCwKICAgIC8vICAgICBmZWU6IDAsCiAgICAvLyAgIH0pCiAgICBwdXNoaW50IDQgLy8gNAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo0MDgKICAgIC8vIGZlZTogMCwKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo0MDMtNDEwCiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICB4ZmVyQXNzZXQ6IHRva2VuSWQsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IDAsCiAgICAvLyAgICAgZmVlOiAwLAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCk7CiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo0MDAKICAgIC8vIEBhYmltZXRob2QoKQogICAgYnl0ZWNfMiAvLyAweDE1MWY3Yzc1MDAyMAogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo0MTIKICAgIC8vIHJldHVybiBUeG4udHhJZDsKICAgIHR4biBUeElECiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjQwMAogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6OkFsZ29TdGFrZVgud2l0aGRyYXdFeGNlc3NUb2tlbnNbcm91dGluZ10oKSAtPiB2b2lkOgp3aXRoZHJhd0V4Y2Vzc1Rva2VuczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6NDE5CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6NDIzCiAgICAvLyBUeG4uc2VuZGVyID09PSBHbG9iYWwuY3JlYXRvckFkZHJlc3MsCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjQyMi00MjUKICAgIC8vIGFzc2VydCgKICAgIC8vICAgVHhuLnNlbmRlciA9PT0gR2xvYmFsLmNyZWF0b3JBZGRyZXNzLAogICAgLy8gICAiT25seSBhZG1pbiBjYW4gd2l0aGRyYXcgZXhjZXNzIgogICAgLy8gKTsKICAgIGFzc2VydCAvLyBPbmx5IGFkbWluIGNhbiB3aXRoZHJhdyBleGNlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6NDI5LTQzNgogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogVHhuLnNlbmRlciwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IHRva2VuSWQsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICBmZWU6IDAsCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKTsKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6NDMxCiAgICAvLyBhc3NldFJlY2VpdmVyOiBUeG4uc2VuZGVyLAogICAgdHhuIFNlbmRlcgogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo0MjktNDM1CiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBUeG4uc2VuZGVyLAogICAgLy8gICAgIHhmZXJBc3NldDogdG9rZW5JZCwKICAgIC8vICAgICBhc3NldEFtb3VudDogYW1vdW50LAogICAgLy8gICAgIGZlZTogMCwKICAgIC8vICAgfSkKICAgIHB1c2hpbnQgNCAvLyA0CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjQzNAogICAgLy8gZmVlOiAwLAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjQyOS00MzYKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IFR4bi5zZW5kZXIsCiAgICAvLyAgICAgeGZlckFzc2V0OiB0b2tlbklkLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyAgICAgZmVlOiAwLAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCk7CiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo0MTkKICAgIC8vIEBhYmltZXRob2QoKQogICAgYnl0ZWNfMiAvLyAweDE1MWY3Yzc1MDAyMAogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo0MzgKICAgIC8vIHJldHVybiBUeG4udHhJZDsKICAgIHR4biBUeElECiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjQxOQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6OkFsZ29TdGFrZVguZnVuZENvbnRyYWN0W3JvdXRpbmddKCkgLT4gdm9pZDoKZnVuZENvbnRyYWN0OgogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo0NDQKICAgIC8vIEBhYmltZXRob2QoKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo0NDcKICAgIC8vIFR4bi5zZW5kZXIgPT09IEdsb2JhbC5jcmVhdG9yQWRkcmVzcywKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6NDQ2LTQ0OQogICAgLy8gYXNzZXJ0KAogICAgLy8gICBUeG4uc2VuZGVyID09PSBHbG9iYWwuY3JlYXRvckFkZHJlc3MsCiAgICAvLyAgICJPbmx5IGFkbWluIGNhbiBmdW5kIHRoZSBjb250cmFjdCIKICAgIC8vICk7CiAgICBhc3NlcnQgLy8gT25seSBhZG1pbiBjYW4gZnVuZCB0aGUgY29udHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6NDUxLTQ1NwogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgYW1vdW50OiBhbW91bnQsCiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGZlZTogMCwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpOwogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo0NTQKICAgIC8vIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo0NTEtNDU2CiAgICAvLyBpdHhuCiAgICAvLyAgIC5wYXltZW50KHsKICAgIC8vICAgICBhbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgZmVlOiAwLAogICAgLy8gICB9KQogICAgaW50Y18yIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6NDU1CiAgICAvLyBmZWU6IDAsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6NDUxLTQ1NwogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgYW1vdW50OiBhbW91bnQsCiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGZlZTogMCwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpOwogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6NDQ0CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjpBbGdvU3Rha2VYLndpdGhkcmF3RXhjZXNzQWxnb1tyb3V0aW5nXSgpIC0+IHZvaWQ6CndpdGhkcmF3RXhjZXNzQWxnbzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6NDY2CiAgICAvLyBUeG4uc2VuZGVyID09PSBHbG9iYWwuY3JlYXRvckFkZHJlc3MsCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjQ2NS00NjgKICAgIC8vIGFzc2VydCgKICAgIC8vICAgVHhuLnNlbmRlciA9PT0gR2xvYmFsLmNyZWF0b3JBZGRyZXNzLAogICAgLy8gICAiT25seSBhZG1pbiBjYW4gd2l0aGRyYXcgZnVuZHMiCiAgICAvLyApOwogICAgYXNzZXJ0IC8vIE9ubHkgYWRtaW4gY2FuIHdpdGhkcmF3IGZ1bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjQ3MQogICAgLy8gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MuYmFsYW5jZSAtIE1JTl9CQUxBTkNFCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RCYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIHB1c2hpbnQgMTAwMDAwIC8vIDEwMDAwMAogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo0NzQKICAgIC8vIGFzc2VydChhbW91bnRUb1dpdGhkcmF3ID4gVWludDY0KDApLCAiTm8gZXhjZXNzIGJhbGFuY2UgdG8gd2l0aGRyYXciKTsKICAgIGR1cAogICAgYXNzZXJ0IC8vIE5vIGV4Y2VzcyBiYWxhbmNlIHRvIHdpdGhkcmF3CiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjQ3Ni00ODIKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIGFtb3VudDogYW1vdW50VG9XaXRoZHJhdywKICAgIC8vICAgICByZWNlaXZlcjogVHhuLnNlbmRlciwKICAgIC8vICAgICBmZWU6IDAsCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKTsKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9BbGdvU3Rha2VYL2NvbnRyYWN0LmFsZ28udHM6NDc5CiAgICAvLyByZWNlaXZlcjogVHhuLnNlbmRlciwKICAgIHR4biBTZW5kZXIKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvQWxnb1N0YWtlWC9jb250cmFjdC5hbGdvLnRzOjQ3Ni00ODEKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIGFtb3VudDogYW1vdW50VG9XaXRoZHJhdywKICAgIC8vICAgICByZWNlaXZlcjogVHhuLnNlbmRlciwKICAgIC8vICAgICBmZWU6IDAsCiAgICAvLyAgIH0pCiAgICBpbnRjXzIgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo0ODAKICAgIC8vIGZlZTogMCwKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo0NzYtNDgyCiAgICAvLyBpdHhuCiAgICAvLyAgIC5wYXltZW50KHsKICAgIC8vICAgICBhbW91bnQ6IGFtb3VudFRvV2l0aGRyYXcsCiAgICAvLyAgICAgcmVjZWl2ZXI6IFR4bi5zZW5kZXIsCiAgICAvLyAgICAgZmVlOiAwLAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCk7CiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL0FsZ29TdGFrZVgvY29udHJhY3QuYWxnby50czo0NjMKICAgIC8vIEBhYmltZXRob2QoKQogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgo=","clear":"I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg=="},"byteCode":{"approval":"CyAEAAgBAiYFAwABXwZzdGFrZV8GFR98dQAgAgBVBBUffHUxG0EATjEZFEQxGESCCQSlCCEZBPXYo0sE6gC//wSRrikeBO9yPI0EjY/awgR3K1V0BFXZUlsEMGdpeDYaAI4JAAsBSAG3AkcCngLOAvcDJwNGADEZFDEYFBBEJEM2GgFJIlklCEsBFRJENhoCSU4CSRUjEkQXNhoDSU4DFSQSRDYaBElOA0kVIxJEF04CNhoFSU4DSRUjEkQXTgI2GgZJTgNJIlklCEsBFUlOBRJEVwIANhoHSU4ESRUjEkQXTgM2GghJTgRJIlklCEwVEkRPAihQMQBQTgKxMgoishJPArIRshSBBLIQIrIBszIHTIADQVBZEkAABEsDFEQpSwJQSb1FAUEAVTEATEmBICO6SwGBKSO6F0sNCBZLAoExI7pLBUsNCBZPBU8EUEsQUE8DUE8CUEsLUExQK1CBVUsICExLB1BMFlcGAlBLCFBLBFBLAbxIvyoxF1CwJEMxAEsCSRZMSwsIFk8CSxBQSw9QSw5QTwJQSwtQTFArUIFVSwgITEsHUEwWVwYCUEsIUEsEUExJvEhMv0L/uzYaAUkiWSUISwEVEkQoUDEAUClMUEcCvUUBRDEASwEigSC6EkQyB0yBKCS6IlOAAQAiTwJUIlNAAAtLAYFBI7oXSwEORLExAEsCSYEgI7oXSwGBKSO6F7ISshFMshSBBLIQIrIBs7xIKjEXULAkQzYaAUkiWSUISwEVEkQ2GgJJFSMSRBc2GgNJTgMVgSASREwoUDEAUClMUElOAkm9RQFEMQBLASKBILoSREmBKSO6F0lPAwuBkE4KSU4DTEsBCbExAE8DgSAjuhdJTgRPArISshGyFIEEshAisgGzQQAUsUsBshJJshFLA7IUgQSyECKyAbNLArxIKjEXULAkQzYaAUkiWSUISwEVEkQ2GgJJIlklCEsBFRJENhoDSRUjEkQXTgJMKFBMUClMUEm9RQFAAA8igAEAIk8CVCcETFCwJENJgSkjuhdLAgxBAAQiQv/iJEL/3jYaAUkiWSUISwEVEkQ2GgJJIlklCEsBFRJETChQTFApTFBJvUUBRL5IJwRMULAkQzYaAUkVIxJEFzYaAhUjEkSxMgoishKyFLIRgQSyECKyAbMqMRdQsCRDNhoBSRUjEkQXNhoCSRUjEkQXMQAyCRJEsTEAshSyErIRgQSyECKyAbMqMRdQsCRDNhoBSRUjEkQXMQAyCRJEsTIKsgeyCCSyECKyAbMkQzEAMgkSRDIKcwBEgaCNBglJRLExALIHsggkshAisgGzJEM=","clear":"C4EBQw=="},"events":[],"templateVariables":{}} as unknown as Arc56Contract

/**
 * A state record containing binary data
 */
export interface BinaryState {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array | undefined
  /**
   * Gets the state value as a string
   */
  asString(): string | undefined
}

class BinaryStateValue implements BinaryState {
  constructor(private value: Uint8Array | undefined) {}

  asByteArray(): Uint8Array | undefined {
    return this.value
  }

  asString(): string | undefined {
    return this.value !== undefined ? Buffer.from(this.value).toString('utf-8') : undefined
  }
}

/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R
  ? (...args: Expand<A>) => Expand<R>
  : T extends infer O
    ? { [K in keyof O]: O[K] }
    : never


// Type definitions for ARC-56 structs

export type StakeData = {
  staker: string,
  tokenId: bigint,
  isFlexible: boolean,
  amount: bigint,
  stakedAt: bigint,
  lockPeriod: bigint,
  lockEndTime: bigint,
  rewardType: string,
  rewardRate: bigint,
  utility: string
}


/**
 * Converts the ABI tuple representation of a StakeData to the struct representation
 */
export function StakeDataFromTuple(abiTuple: [string, bigint, boolean, bigint, bigint, bigint, bigint, string, bigint, string]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.StakeData, APP_SPEC.structs) as StakeData
}

/**
 * The argument types for the AlgoStakeX contract
 */
export type AlgoStakeXArgs = {
  /**
   * The object representation of the arguments for each method
   */
  obj: {
    'stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]': {
      poolId: string
      tokenId: bigint | number
      isFlexible: boolean
      amount: bigint | number
      lockPeriod: bigint | number
      rewardType: string
      rewardRate: bigint | number
      utility: string
    }
    'withdraw(string)byte[]': {
      poolId: string
    }
    'emergencyWithdraw(string,uint64,address)byte[]': {
      poolId: string
      penaltyPercentage: bigint | number
      treasuryAddress: string
    }
    'hasValidStake(string,string,uint64)bool': {
      poolId: string
      userAddress: string
      minimumAmount: bigint | number
    }
    'getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)': {
      poolId: string
      userAddress: string
    }
    'donateTokens(uint64,uint64)byte[]': {
      tokenId: bigint | number
      amount: bigint | number
    }
    'withdrawExcessTokens(uint64,uint64)byte[]': {
      tokenId: bigint | number
      amount: bigint | number
    }
    'fundContract(uint64)void': {
      amount: bigint | number
    }
    'withdrawExcessAlgo()void': Record<string, never>
  }
  /**
   * The tuple representation of the arguments for each method
   */
  tuple: {
    'stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]': [poolId: string, tokenId: bigint | number, isFlexible: boolean, amount: bigint | number, lockPeriod: bigint | number, rewardType: string, rewardRate: bigint | number, utility: string]
    'withdraw(string)byte[]': [poolId: string]
    'emergencyWithdraw(string,uint64,address)byte[]': [poolId: string, penaltyPercentage: bigint | number, treasuryAddress: string]
    'hasValidStake(string,string,uint64)bool': [poolId: string, userAddress: string, minimumAmount: bigint | number]
    'getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)': [poolId: string, userAddress: string]
    'donateTokens(uint64,uint64)byte[]': [tokenId: bigint | number, amount: bigint | number]
    'withdrawExcessTokens(uint64,uint64)byte[]': [tokenId: bigint | number, amount: bigint | number]
    'fundContract(uint64)void': [amount: bigint | number]
    'withdrawExcessAlgo()void': []
  }
}

/**
 * The return type for each method
 */
export type AlgoStakeXReturns = {
  'stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]': Uint8Array
  'withdraw(string)byte[]': Uint8Array
  'emergencyWithdraw(string,uint64,address)byte[]': Uint8Array
  'hasValidStake(string,string,uint64)bool': boolean
  'getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)': StakeData
  'donateTokens(uint64,uint64)byte[]': Uint8Array
  'withdrawExcessTokens(uint64,uint64)byte[]': Uint8Array
  'fundContract(uint64)void': void
  'withdrawExcessAlgo()void': void
}

/**
 * Defines the types of available calls and state of the AlgoStakeX smart contract.
 */
export type AlgoStakeXTypes = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]' | 'stake', {
      argsObj: AlgoStakeXArgs['obj']['stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]']
      argsTuple: AlgoStakeXArgs['tuple']['stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]']
      returns: AlgoStakeXReturns['stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]']
    }>
    & Record<'withdraw(string)byte[]' | 'withdraw', {
      argsObj: AlgoStakeXArgs['obj']['withdraw(string)byte[]']
      argsTuple: AlgoStakeXArgs['tuple']['withdraw(string)byte[]']
      returns: AlgoStakeXReturns['withdraw(string)byte[]']
    }>
    & Record<'emergencyWithdraw(string,uint64,address)byte[]' | 'emergencyWithdraw', {
      argsObj: AlgoStakeXArgs['obj']['emergencyWithdraw(string,uint64,address)byte[]']
      argsTuple: AlgoStakeXArgs['tuple']['emergencyWithdraw(string,uint64,address)byte[]']
      returns: AlgoStakeXReturns['emergencyWithdraw(string,uint64,address)byte[]']
    }>
    & Record<'hasValidStake(string,string,uint64)bool' | 'hasValidStake', {
      argsObj: AlgoStakeXArgs['obj']['hasValidStake(string,string,uint64)bool']
      argsTuple: AlgoStakeXArgs['tuple']['hasValidStake(string,string,uint64)bool']
      returns: AlgoStakeXReturns['hasValidStake(string,string,uint64)bool']
    }>
    & Record<'getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)' | 'getStakeInfo', {
      argsObj: AlgoStakeXArgs['obj']['getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)']
      argsTuple: AlgoStakeXArgs['tuple']['getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)']
      returns: AlgoStakeXReturns['getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)']
    }>
    & Record<'donateTokens(uint64,uint64)byte[]' | 'donateTokens', {
      argsObj: AlgoStakeXArgs['obj']['donateTokens(uint64,uint64)byte[]']
      argsTuple: AlgoStakeXArgs['tuple']['donateTokens(uint64,uint64)byte[]']
      returns: AlgoStakeXReturns['donateTokens(uint64,uint64)byte[]']
    }>
    & Record<'withdrawExcessTokens(uint64,uint64)byte[]' | 'withdrawExcessTokens', {
      argsObj: AlgoStakeXArgs['obj']['withdrawExcessTokens(uint64,uint64)byte[]']
      argsTuple: AlgoStakeXArgs['tuple']['withdrawExcessTokens(uint64,uint64)byte[]']
      returns: AlgoStakeXReturns['withdrawExcessTokens(uint64,uint64)byte[]']
    }>
    & Record<'fundContract(uint64)void' | 'fundContract', {
      argsObj: AlgoStakeXArgs['obj']['fundContract(uint64)void']
      argsTuple: AlgoStakeXArgs['tuple']['fundContract(uint64)void']
      returns: AlgoStakeXReturns['fundContract(uint64)void']
    }>
    & Record<'withdrawExcessAlgo()void' | 'withdrawExcessAlgo', {
      argsObj: AlgoStakeXArgs['obj']['withdrawExcessAlgo()void']
      argsTuple: AlgoStakeXArgs['tuple']['withdrawExcessAlgo()void']
      returns: AlgoStakeXReturns['withdrawExcessAlgo()void']
    }>
  /**
   * Defines the shape of the state of the application.
   */
  state: {
    box: {
      keys: {}
      maps: {
        stakes: Map<Uint8Array | string, StakeData>
      }
    }
  }
}

/**
 * Defines the possible abi call signatures.
 */
export type AlgoStakeXSignatures = keyof AlgoStakeXTypes['methods']
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type AlgoStakeXNonVoidMethodSignatures = keyof AlgoStakeXTypes['methods'] extends infer T ? T extends keyof AlgoStakeXTypes['methods'] ? MethodReturn<T> extends void ? never : T  : never : never
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<
  Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> &
    {
      /** The args for the ABI method call, either as an ordered array or an object */
      args: Expand<TArgs>
    }
>
/**
 * Maps a method signature from the AlgoStakeX smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends AlgoStakeXSignatures> = AlgoStakeXTypes['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the AlgoStakeX smart contract to the method's return type
 */
export type MethodReturn<TSignature extends AlgoStakeXSignatures> = AlgoStakeXTypes['methods'][TSignature]['returns']

/**
 * Defines the shape of the keyed box state of the application.
 */
export type BoxKeysState = AlgoStakeXTypes['state']['box']['keys']


/**
 * Defines supported create method params for this smart contract
 */
export type AlgoStakeXCreateCallParams =
  | Expand<AppClientBareCallParams & {method?: never} & {onComplete?: OnApplicationComplete.NoOpOC} & CreateSchema>
/**
 * Defines arguments required for the deploy method.
 */
export type AlgoStakeXDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
  /**
   * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  createParams?: AlgoStakeXCreateCallParams
}>


/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the AlgoStakeX smart contract
 */
export abstract class AlgoStakeXParamsFactory {
  /**
   * Constructs a no op call for the stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[] ABI method
   *
  * Stake tokens into a pool
  Transaction group expected:
  [0] App call: stake
  [1] Asset transfer: User → Contract

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static stake(params: CallParams<AlgoStakeXArgs['obj']['stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]'] | AlgoStakeXArgs['tuple']['stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.poolId, params.args.tokenId, params.args.isFlexible, params.args.amount, params.args.lockPeriod, params.args.rewardType, params.args.rewardRate, params.args.utility],
    }
  }
  /**
   * Constructs a no op call for the withdraw(string)byte[] ABI method
   *
   * Withdraw staked tokens with rewards
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static withdraw(params: CallParams<AlgoStakeXArgs['obj']['withdraw(string)byte[]'] | AlgoStakeXArgs['tuple']['withdraw(string)byte[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'withdraw(string)byte[]' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.poolId],
    }
  }
  /**
   * Constructs a no op call for the emergencyWithdraw(string,uint64,address)byte[] ABI method
   *
  * Emergency withdraw with penalty (for locked staking)
  Penalty tokens are sent to treasury wallet for recycling

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static emergencyWithdraw(params: CallParams<AlgoStakeXArgs['obj']['emergencyWithdraw(string,uint64,address)byte[]'] | AlgoStakeXArgs['tuple']['emergencyWithdraw(string,uint64,address)byte[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'emergencyWithdraw(string,uint64,address)byte[]' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.poolId, params.args.penaltyPercentage, params.args.treasuryAddress],
    }
  }
  /**
   * Constructs a no op call for the hasValidStake(string,string,uint64)bool ABI method
   *
   * Check if user has valid stake (for access control)
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static hasValidStake(params: CallParams<AlgoStakeXArgs['obj']['hasValidStake(string,string,uint64)bool'] | AlgoStakeXArgs['tuple']['hasValidStake(string,string,uint64)bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'hasValidStake(string,string,uint64)bool' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.poolId, params.args.userAddress, params.args.minimumAmount],
    }
  }
  /**
   * Constructs a no op call for the getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string) ABI method
   *
   * Get stake information for a user
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getStakeInfo(params: CallParams<AlgoStakeXArgs['obj']['getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)'] | AlgoStakeXArgs['tuple']['getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.poolId, params.args.userAddress],
    }
  }
  /**
   * Constructs a no op call for the donateTokens(uint64,uint64)byte[] ABI method
   *
  * Donate tokens to contract (no staking)
  Transaction group:
  [0] App call: donateTokens
  [1] Asset transfer: User → Contract

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static donateTokens(params: CallParams<AlgoStakeXArgs['obj']['donateTokens(uint64,uint64)byte[]'] | AlgoStakeXArgs['tuple']['donateTokens(uint64,uint64)byte[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'donateTokens(uint64,uint64)byte[]' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.tokenId, params.args.amount],
    }
  }
  /**
   * Constructs a no op call for the withdrawExcessTokens(uint64,uint64)byte[] ABI method
   *
  * Withdraw excess tokens from contract (admin only)
  Only withdraws tokens that are NOT currently staked

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static withdrawExcessTokens(params: CallParams<AlgoStakeXArgs['obj']['withdrawExcessTokens(uint64,uint64)byte[]'] | AlgoStakeXArgs['tuple']['withdrawExcessTokens(uint64,uint64)byte[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'withdrawExcessTokens(uint64,uint64)byte[]' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.tokenId, params.args.amount],
    }
  }
  /**
   * Constructs a no op call for the fundContract(uint64)void ABI method
   *
   * Fund contract with ALGO for MBR
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static fundContract(params: CallParams<AlgoStakeXArgs['obj']['fundContract(uint64)void'] | AlgoStakeXArgs['tuple']['fundContract(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'fundContract(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.amount],
    }
  }
  /**
   * Constructs a no op call for the withdrawExcessAlgo()void ABI method
   *
   * Withdraw excess ALGO from contract
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static withdrawExcessAlgo(params: CallParams<AlgoStakeXArgs['obj']['withdrawExcessAlgo()void'] | AlgoStakeXArgs['tuple']['withdrawExcessAlgo()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'withdrawExcessAlgo()void' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
}

/**
 * A factory to create and deploy one or more instance of the AlgoStakeX smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export class AlgoStakeXFactory {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  public readonly appFactory: _AppFactory

  /**
   * Creates a new instance of `AlgoStakeXFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params: Omit<AppFactoryParams, 'appSpec'>) {
    this.appFactory = new _AppFactory({
      ...params,
      appSpec: APP_SPEC,
    })
  }
  
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  public get appName() {
    return this.appFactory.appName
  }
  
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC
  }
  
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  public get algorand(): AlgorandClient {
    return this.appFactory.algorand
  }
  
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public getAppClientById(params: AppFactoryAppClientParams) {
    return new AlgoStakeXClient(this.appFactory.getAppClientById(params))
  }
  
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public async getAppClientByCreatorAndName(
    params: AppFactoryResolveAppClientByCreatorAndNameParams,
  ) {
    return new AlgoStakeXClient(await this.appFactory.getAppClientByCreatorAndName(params))
  }

  /**
   * Idempotently deploys the AlgoStakeX smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public async deploy(params: AlgoStakeXDeployParams = {}) {
    const result = await this.appFactory.deploy({
      ...params,
    })
    return { result: result.result, appClient: new AlgoStakeXClient(result.appClient) }
  }

  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the AlgoStakeX smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The params for a create call
       */
      bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}>) => {
        return this.appFactory.params.bare.create(params)
      },
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the AlgoStakeX smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The transaction for a create call
       */
      bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}>) => {
        return this.appFactory.createTransaction.bare.create(params)
      },
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the AlgoStakeX smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The create result
       */
      bare: async (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}>) => {
        const result = await this.appFactory.send.bare.create(params)
        return { result: result.result, appClient: new AlgoStakeXClient(result.appClient) }
      },
    },

  }

}
/**
 * A client to make calls to the AlgoStakeX smart contract
 */
export class AlgoStakeXClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  public readonly appClient: _AppClient

  /**
   * Creates a new instance of `AlgoStakeXClient`
   *
   * @param appClient An `AppClient` instance which has been created with the AlgoStakeX app spec
   */
  constructor(appClient: _AppClient)
  /**
   * Creates a new instance of `AlgoStakeXClient`
   *
   * @param params The parameters to initialise the app client with
   */
  constructor(params: Omit<AppClientParams, 'appSpec'>)
  constructor(appClientOrParams: _AppClient | Omit<AppClientParams, 'appSpec'>) {
    this.appClient = appClientOrParams instanceof _AppClient ? appClientOrParams : new _AppClient({
      ...appClientOrParams,
      appSpec: APP_SPEC,
    })
  }
  
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue<TSignature extends AlgoStakeXNonVoidMethodSignatures>(method: TSignature, returnValue: ABIReturn | undefined) {
    return returnValue !== undefined ? getArc56ReturnValue<MethodReturn<TSignature>>(returnValue, this.appClient.getABIMethod(method), APP_SPEC.structs) : undefined
  }
  
  /**
   * Returns a new `AlgoStakeXClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  public static async fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<AlgoStakeXClient> {
    return new AlgoStakeXClient(await _AppClient.fromCreatorAndName({...params, appSpec: APP_SPEC}))
  }
  
  /**
   * Returns an `AlgoStakeXClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(
    params: Omit<ResolveAppClientByNetwork, 'appSpec'>
  ): Promise<AlgoStakeXClient> {
    return new AlgoStakeXClient(await _AppClient.fromNetwork({...params, appSpec: APP_SPEC}))
  }
  
  /** The ID of the app instance this client is linked to. */
  public get appId() {
    return this.appClient.appId
  }
  
  /** The app address of the app instance this client is linked to. */
  public get appAddress() {
    return this.appClient.appAddress
  }
  
  /** The name of the app. */
  public get appName() {
    return this.appClient.appName
  }
  
  /** The ARC-56 app spec being used */
  public get appSpec() {
    return this.appClient.appSpec
  }
  
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  public get algorand(): AlgorandClient {
    return this.appClient.algorand
  }

  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Makes a clear_state call to an existing instance of the AlgoStakeX smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.params.bare.clearState(params)
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]` ABI method.
     *
    * Stake tokens into a pool
    Transaction group expected:
    [0] App call: stake
    [1] Asset transfer: User → Contract

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    stake: (params: CallParams<AlgoStakeXArgs['obj']['stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]'] | AlgoStakeXArgs['tuple']['stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(AlgoStakeXParamsFactory.stake(params))
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `withdraw(string)byte[]` ABI method.
     *
     * Withdraw staked tokens with rewards
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    withdraw: (params: CallParams<AlgoStakeXArgs['obj']['withdraw(string)byte[]'] | AlgoStakeXArgs['tuple']['withdraw(string)byte[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(AlgoStakeXParamsFactory.withdraw(params))
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `emergencyWithdraw(string,uint64,address)byte[]` ABI method.
     *
    * Emergency withdraw with penalty (for locked staking)
    Penalty tokens are sent to treasury wallet for recycling

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    emergencyWithdraw: (params: CallParams<AlgoStakeXArgs['obj']['emergencyWithdraw(string,uint64,address)byte[]'] | AlgoStakeXArgs['tuple']['emergencyWithdraw(string,uint64,address)byte[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(AlgoStakeXParamsFactory.emergencyWithdraw(params))
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `hasValidStake(string,string,uint64)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Check if user has valid stake (for access control)
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    hasValidStake: (params: CallParams<AlgoStakeXArgs['obj']['hasValidStake(string,string,uint64)bool'] | AlgoStakeXArgs['tuple']['hasValidStake(string,string,uint64)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(AlgoStakeXParamsFactory.hasValidStake(params))
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get stake information for a user
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getStakeInfo: (params: CallParams<AlgoStakeXArgs['obj']['getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)'] | AlgoStakeXArgs['tuple']['getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(AlgoStakeXParamsFactory.getStakeInfo(params))
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `donateTokens(uint64,uint64)byte[]` ABI method.
     *
    * Donate tokens to contract (no staking)
    Transaction group:
    [0] App call: donateTokens
    [1] Asset transfer: User → Contract

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    donateTokens: (params: CallParams<AlgoStakeXArgs['obj']['donateTokens(uint64,uint64)byte[]'] | AlgoStakeXArgs['tuple']['donateTokens(uint64,uint64)byte[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(AlgoStakeXParamsFactory.donateTokens(params))
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `withdrawExcessTokens(uint64,uint64)byte[]` ABI method.
     *
    * Withdraw excess tokens from contract (admin only)
    Only withdraws tokens that are NOT currently staked

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    withdrawExcessTokens: (params: CallParams<AlgoStakeXArgs['obj']['withdrawExcessTokens(uint64,uint64)byte[]'] | AlgoStakeXArgs['tuple']['withdrawExcessTokens(uint64,uint64)byte[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(AlgoStakeXParamsFactory.withdrawExcessTokens(params))
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `fundContract(uint64)void` ABI method.
     *
     * Fund contract with ALGO for MBR
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    fundContract: (params: CallParams<AlgoStakeXArgs['obj']['fundContract(uint64)void'] | AlgoStakeXArgs['tuple']['fundContract(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(AlgoStakeXParamsFactory.fundContract(params))
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `withdrawExcessAlgo()void` ABI method.
     *
     * Withdraw excess ALGO from contract
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    withdrawExcessAlgo: (params: CallParams<AlgoStakeXArgs['obj']['withdrawExcessAlgo()void'] | AlgoStakeXArgs['tuple']['withdrawExcessAlgo()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(AlgoStakeXParamsFactory.withdrawExcessAlgo(params))
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the AlgoStakeX smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.createTransaction.bare.clearState(params)
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]` ABI method.
     *
    * Stake tokens into a pool
    Transaction group expected:
    [0] App call: stake
    [1] Asset transfer: User → Contract

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    stake: (params: CallParams<AlgoStakeXArgs['obj']['stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]'] | AlgoStakeXArgs['tuple']['stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(AlgoStakeXParamsFactory.stake(params))
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `withdraw(string)byte[]` ABI method.
     *
     * Withdraw staked tokens with rewards
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    withdraw: (params: CallParams<AlgoStakeXArgs['obj']['withdraw(string)byte[]'] | AlgoStakeXArgs['tuple']['withdraw(string)byte[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(AlgoStakeXParamsFactory.withdraw(params))
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `emergencyWithdraw(string,uint64,address)byte[]` ABI method.
     *
    * Emergency withdraw with penalty (for locked staking)
    Penalty tokens are sent to treasury wallet for recycling

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    emergencyWithdraw: (params: CallParams<AlgoStakeXArgs['obj']['emergencyWithdraw(string,uint64,address)byte[]'] | AlgoStakeXArgs['tuple']['emergencyWithdraw(string,uint64,address)byte[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(AlgoStakeXParamsFactory.emergencyWithdraw(params))
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `hasValidStake(string,string,uint64)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Check if user has valid stake (for access control)
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    hasValidStake: (params: CallParams<AlgoStakeXArgs['obj']['hasValidStake(string,string,uint64)bool'] | AlgoStakeXArgs['tuple']['hasValidStake(string,string,uint64)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(AlgoStakeXParamsFactory.hasValidStake(params))
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get stake information for a user
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getStakeInfo: (params: CallParams<AlgoStakeXArgs['obj']['getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)'] | AlgoStakeXArgs['tuple']['getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(AlgoStakeXParamsFactory.getStakeInfo(params))
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `donateTokens(uint64,uint64)byte[]` ABI method.
     *
    * Donate tokens to contract (no staking)
    Transaction group:
    [0] App call: donateTokens
    [1] Asset transfer: User → Contract

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    donateTokens: (params: CallParams<AlgoStakeXArgs['obj']['donateTokens(uint64,uint64)byte[]'] | AlgoStakeXArgs['tuple']['donateTokens(uint64,uint64)byte[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(AlgoStakeXParamsFactory.donateTokens(params))
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `withdrawExcessTokens(uint64,uint64)byte[]` ABI method.
     *
    * Withdraw excess tokens from contract (admin only)
    Only withdraws tokens that are NOT currently staked

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    withdrawExcessTokens: (params: CallParams<AlgoStakeXArgs['obj']['withdrawExcessTokens(uint64,uint64)byte[]'] | AlgoStakeXArgs['tuple']['withdrawExcessTokens(uint64,uint64)byte[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(AlgoStakeXParamsFactory.withdrawExcessTokens(params))
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `fundContract(uint64)void` ABI method.
     *
     * Fund contract with ALGO for MBR
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    fundContract: (params: CallParams<AlgoStakeXArgs['obj']['fundContract(uint64)void'] | AlgoStakeXArgs['tuple']['fundContract(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(AlgoStakeXParamsFactory.fundContract(params))
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `withdrawExcessAlgo()void` ABI method.
     *
     * Withdraw excess ALGO from contract
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    withdrawExcessAlgo: (params: CallParams<AlgoStakeXArgs['obj']['withdrawExcessAlgo()void'] | AlgoStakeXArgs['tuple']['withdrawExcessAlgo()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(AlgoStakeXParamsFactory.withdrawExcessAlgo(params))
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Makes a clear_state call to an existing instance of the AlgoStakeX smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => {
      return this.appClient.send.bare.clearState(params)
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]` ABI method.
     *
    * Stake tokens into a pool
    Transaction group expected:
    [0] App call: stake
    [1] Asset transfer: User → Contract

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    stake: async (params: CallParams<AlgoStakeXArgs['obj']['stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]'] | AlgoStakeXArgs['tuple']['stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(AlgoStakeXParamsFactory.stake(params))
      return {...result, return: result.return as unknown as (undefined | AlgoStakeXReturns['stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]'])}
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `withdraw(string)byte[]` ABI method.
     *
     * Withdraw staked tokens with rewards
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    withdraw: async (params: CallParams<AlgoStakeXArgs['obj']['withdraw(string)byte[]'] | AlgoStakeXArgs['tuple']['withdraw(string)byte[]']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(AlgoStakeXParamsFactory.withdraw(params))
      return {...result, return: result.return as unknown as (undefined | AlgoStakeXReturns['withdraw(string)byte[]'])}
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `emergencyWithdraw(string,uint64,address)byte[]` ABI method.
     *
    * Emergency withdraw with penalty (for locked staking)
    Penalty tokens are sent to treasury wallet for recycling

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    emergencyWithdraw: async (params: CallParams<AlgoStakeXArgs['obj']['emergencyWithdraw(string,uint64,address)byte[]'] | AlgoStakeXArgs['tuple']['emergencyWithdraw(string,uint64,address)byte[]']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(AlgoStakeXParamsFactory.emergencyWithdraw(params))
      return {...result, return: result.return as unknown as (undefined | AlgoStakeXReturns['emergencyWithdraw(string,uint64,address)byte[]'])}
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `hasValidStake(string,string,uint64)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Check if user has valid stake (for access control)
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    hasValidStake: async (params: CallParams<AlgoStakeXArgs['obj']['hasValidStake(string,string,uint64)bool'] | AlgoStakeXArgs['tuple']['hasValidStake(string,string,uint64)bool']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(AlgoStakeXParamsFactory.hasValidStake(params))
      return {...result, return: result.return as unknown as (undefined | AlgoStakeXReturns['hasValidStake(string,string,uint64)bool'])}
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get stake information for a user
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getStakeInfo: async (params: CallParams<AlgoStakeXArgs['obj']['getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)'] | AlgoStakeXArgs['tuple']['getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(AlgoStakeXParamsFactory.getStakeInfo(params))
      return {...result, return: result.return as unknown as (undefined | AlgoStakeXReturns['getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)'])}
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `donateTokens(uint64,uint64)byte[]` ABI method.
     *
    * Donate tokens to contract (no staking)
    Transaction group:
    [0] App call: donateTokens
    [1] Asset transfer: User → Contract

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    donateTokens: async (params: CallParams<AlgoStakeXArgs['obj']['donateTokens(uint64,uint64)byte[]'] | AlgoStakeXArgs['tuple']['donateTokens(uint64,uint64)byte[]']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(AlgoStakeXParamsFactory.donateTokens(params))
      return {...result, return: result.return as unknown as (undefined | AlgoStakeXReturns['donateTokens(uint64,uint64)byte[]'])}
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `withdrawExcessTokens(uint64,uint64)byte[]` ABI method.
     *
    * Withdraw excess tokens from contract (admin only)
    Only withdraws tokens that are NOT currently staked

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    withdrawExcessTokens: async (params: CallParams<AlgoStakeXArgs['obj']['withdrawExcessTokens(uint64,uint64)byte[]'] | AlgoStakeXArgs['tuple']['withdrawExcessTokens(uint64,uint64)byte[]']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(AlgoStakeXParamsFactory.withdrawExcessTokens(params))
      return {...result, return: result.return as unknown as (undefined | AlgoStakeXReturns['withdrawExcessTokens(uint64,uint64)byte[]'])}
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `fundContract(uint64)void` ABI method.
     *
     * Fund contract with ALGO for MBR
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    fundContract: async (params: CallParams<AlgoStakeXArgs['obj']['fundContract(uint64)void'] | AlgoStakeXArgs['tuple']['fundContract(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(AlgoStakeXParamsFactory.fundContract(params))
      return {...result, return: result.return as unknown as (undefined | AlgoStakeXReturns['fundContract(uint64)void'])}
    },

    /**
     * Makes a call to the AlgoStakeX smart contract using the `withdrawExcessAlgo()void` ABI method.
     *
     * Withdraw excess ALGO from contract
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    withdrawExcessAlgo: async (params: CallParams<AlgoStakeXArgs['obj']['withdrawExcessAlgo()void'] | AlgoStakeXArgs['tuple']['withdrawExcessAlgo()void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(AlgoStakeXParamsFactory.withdrawExcessAlgo(params))
      return {...result, return: result.return as unknown as (undefined | AlgoStakeXReturns['withdrawExcessAlgo()void'])}
    },

  }

  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  public clone(params: CloneAppClientParams) {
    return new AlgoStakeXClient(this.appClient.clone(params))
  }

  /**
   * Makes a readonly (simulated) call to the AlgoStakeX smart contract using the `hasValidStake(string,string,uint64)bool` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Check if user has valid stake (for access control)
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async hasValidStake(params: CallParams<AlgoStakeXArgs['obj']['hasValidStake(string,string,uint64)bool'] | AlgoStakeXArgs['tuple']['hasValidStake(string,string,uint64)bool']>) {
    const result = await this.appClient.send.call(AlgoStakeXParamsFactory.hasValidStake(params))
    return result.return as unknown as AlgoStakeXReturns['hasValidStake(string,string,uint64)bool']
  }

  /**
   * Makes a readonly (simulated) call to the AlgoStakeX smart contract using the `getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Get stake information for a user
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getStakeInfo(params: CallParams<AlgoStakeXArgs['obj']['getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)'] | AlgoStakeXArgs['tuple']['getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)']>) {
    const result = await this.appClient.send.call(AlgoStakeXParamsFactory.getStakeInfo(params))
    return result.return as unknown as AlgoStakeXReturns['getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)']
  }

  /**
   * Methods to access state for the current AlgoStakeX app
   */
  state = {
    /**
     * Methods to access box state for the current AlgoStakeX app
     */
    box: {
      /**
       * Get all current keyed values from box state
       */
      getAll: async (): Promise<Partial<Expand<BoxKeysState>>> => {
        const result = await this.appClient.state.box.getAll()
        return {
        }
      },
      /**
       * Get values from the stakes map in box state
       */
      stakes: {
        /**
         * Get all current values of the stakes map in box state
         */
        getMap: async (): Promise<Map<Uint8Array, StakeData>> => { return (await this.appClient.state.box.getMap("stakes")) as Map<Uint8Array, StakeData> },
        /**
         * Get a current value of the stakes map by key from box state
         */
        value: async (key: Uint8Array | string): Promise<StakeData | undefined> => { return await this.appClient.state.box.getMapValue("stakes", key) as StakeData | undefined },
      },
    },
  }

  public newGroup(): AlgoStakeXComposer {
    const client = this
    const composer = this.algorand.newGroup()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: ABIReturn | undefined) => any)> = []
    return {
      /**
       * Add a stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[] method call against the AlgoStakeX contract
       */
      stake(params: CallParams<AlgoStakeXArgs['obj']['stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]'] | AlgoStakeXArgs['tuple']['stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.stake(params)))
        resultMappers.push((v) => client.decodeReturnValue('stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]', v))
        return this
      },
      /**
       * Add a withdraw(string)byte[] method call against the AlgoStakeX contract
       */
      withdraw(params: CallParams<AlgoStakeXArgs['obj']['withdraw(string)byte[]'] | AlgoStakeXArgs['tuple']['withdraw(string)byte[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.withdraw(params)))
        resultMappers.push((v) => client.decodeReturnValue('withdraw(string)byte[]', v))
        return this
      },
      /**
       * Add a emergencyWithdraw(string,uint64,address)byte[] method call against the AlgoStakeX contract
       */
      emergencyWithdraw(params: CallParams<AlgoStakeXArgs['obj']['emergencyWithdraw(string,uint64,address)byte[]'] | AlgoStakeXArgs['tuple']['emergencyWithdraw(string,uint64,address)byte[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.emergencyWithdraw(params)))
        resultMappers.push((v) => client.decodeReturnValue('emergencyWithdraw(string,uint64,address)byte[]', v))
        return this
      },
      /**
       * Add a hasValidStake(string,string,uint64)bool method call against the AlgoStakeX contract
       */
      hasValidStake(params: CallParams<AlgoStakeXArgs['obj']['hasValidStake(string,string,uint64)bool'] | AlgoStakeXArgs['tuple']['hasValidStake(string,string,uint64)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.hasValidStake(params)))
        resultMappers.push((v) => client.decodeReturnValue('hasValidStake(string,string,uint64)bool', v))
        return this
      },
      /**
       * Add a getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string) method call against the AlgoStakeX contract
       */
      getStakeInfo(params: CallParams<AlgoStakeXArgs['obj']['getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)'] | AlgoStakeXArgs['tuple']['getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getStakeInfo(params)))
        resultMappers.push((v) => client.decodeReturnValue('getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)', v))
        return this
      },
      /**
       * Add a donateTokens(uint64,uint64)byte[] method call against the AlgoStakeX contract
       */
      donateTokens(params: CallParams<AlgoStakeXArgs['obj']['donateTokens(uint64,uint64)byte[]'] | AlgoStakeXArgs['tuple']['donateTokens(uint64,uint64)byte[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.donateTokens(params)))
        resultMappers.push((v) => client.decodeReturnValue('donateTokens(uint64,uint64)byte[]', v))
        return this
      },
      /**
       * Add a withdrawExcessTokens(uint64,uint64)byte[] method call against the AlgoStakeX contract
       */
      withdrawExcessTokens(params: CallParams<AlgoStakeXArgs['obj']['withdrawExcessTokens(uint64,uint64)byte[]'] | AlgoStakeXArgs['tuple']['withdrawExcessTokens(uint64,uint64)byte[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.withdrawExcessTokens(params)))
        resultMappers.push((v) => client.decodeReturnValue('withdrawExcessTokens(uint64,uint64)byte[]', v))
        return this
      },
      /**
       * Add a fundContract(uint64)void method call against the AlgoStakeX contract
       */
      fundContract(params: CallParams<AlgoStakeXArgs['obj']['fundContract(uint64)void'] | AlgoStakeXArgs['tuple']['fundContract(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.fundContract(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a withdrawExcessAlgo()void method call against the AlgoStakeX contract
       */
      withdrawExcessAlgo(params: CallParams<AlgoStakeXArgs['obj']['withdrawExcessAlgo()void'] | AlgoStakeXArgs['tuple']['withdrawExcessAlgo()void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.withdrawExcessAlgo(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a clear state call to the AlgoStakeX contract
       */
      clearState(params: AppClientBareCallParams) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)))
        return this
      },
      addTransaction(txn: Transaction, signer?: TransactionSigner) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer))
        return this
      },
      async composer() {
        await promiseChain
        return composer
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await (!options ? composer.simulate() : composer.simulate(options))
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      },
      async send(params?: SendParams) {
        await promiseChain
        const result = await composer.send(params)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      }
    } as unknown as AlgoStakeXComposer
  }
}
export type AlgoStakeXComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[] ABI method.
   *
  * Stake tokens into a pool
  Transaction group expected:
  [0] App call: stake
  [1] Asset transfer: User → Contract

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  stake(params?: CallParams<AlgoStakeXArgs['obj']['stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]'] | AlgoStakeXArgs['tuple']['stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]']>): AlgoStakeXComposer<[...TReturns, AlgoStakeXReturns['stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]'] | undefined]>

  /**
   * Calls the withdraw(string)byte[] ABI method.
   *
   * Withdraw staked tokens with rewards
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  withdraw(params?: CallParams<AlgoStakeXArgs['obj']['withdraw(string)byte[]'] | AlgoStakeXArgs['tuple']['withdraw(string)byte[]']>): AlgoStakeXComposer<[...TReturns, AlgoStakeXReturns['withdraw(string)byte[]'] | undefined]>

  /**
   * Calls the emergencyWithdraw(string,uint64,address)byte[] ABI method.
   *
  * Emergency withdraw with penalty (for locked staking)
  Penalty tokens are sent to treasury wallet for recycling

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  emergencyWithdraw(params?: CallParams<AlgoStakeXArgs['obj']['emergencyWithdraw(string,uint64,address)byte[]'] | AlgoStakeXArgs['tuple']['emergencyWithdraw(string,uint64,address)byte[]']>): AlgoStakeXComposer<[...TReturns, AlgoStakeXReturns['emergencyWithdraw(string,uint64,address)byte[]'] | undefined]>

  /**
   * Calls the hasValidStake(string,string,uint64)bool ABI method.
   *
   * Check if user has valid stake (for access control)
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  hasValidStake(params?: CallParams<AlgoStakeXArgs['obj']['hasValidStake(string,string,uint64)bool'] | AlgoStakeXArgs['tuple']['hasValidStake(string,string,uint64)bool']>): AlgoStakeXComposer<[...TReturns, AlgoStakeXReturns['hasValidStake(string,string,uint64)bool'] | undefined]>

  /**
   * Calls the getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string) ABI method.
   *
   * Get stake information for a user
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getStakeInfo(params?: CallParams<AlgoStakeXArgs['obj']['getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)'] | AlgoStakeXArgs['tuple']['getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)']>): AlgoStakeXComposer<[...TReturns, AlgoStakeXReturns['getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)'] | undefined]>

  /**
   * Calls the donateTokens(uint64,uint64)byte[] ABI method.
   *
  * Donate tokens to contract (no staking)
  Transaction group:
  [0] App call: donateTokens
  [1] Asset transfer: User → Contract

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  donateTokens(params?: CallParams<AlgoStakeXArgs['obj']['donateTokens(uint64,uint64)byte[]'] | AlgoStakeXArgs['tuple']['donateTokens(uint64,uint64)byte[]']>): AlgoStakeXComposer<[...TReturns, AlgoStakeXReturns['donateTokens(uint64,uint64)byte[]'] | undefined]>

  /**
   * Calls the withdrawExcessTokens(uint64,uint64)byte[] ABI method.
   *
  * Withdraw excess tokens from contract (admin only)
  Only withdraws tokens that are NOT currently staked

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  withdrawExcessTokens(params?: CallParams<AlgoStakeXArgs['obj']['withdrawExcessTokens(uint64,uint64)byte[]'] | AlgoStakeXArgs['tuple']['withdrawExcessTokens(uint64,uint64)byte[]']>): AlgoStakeXComposer<[...TReturns, AlgoStakeXReturns['withdrawExcessTokens(uint64,uint64)byte[]'] | undefined]>

  /**
   * Calls the fundContract(uint64)void ABI method.
   *
   * Fund contract with ALGO for MBR
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  fundContract(params?: CallParams<AlgoStakeXArgs['obj']['fundContract(uint64)void'] | AlgoStakeXArgs['tuple']['fundContract(uint64)void']>): AlgoStakeXComposer<[...TReturns, AlgoStakeXReturns['fundContract(uint64)void'] | undefined]>

  /**
   * Calls the withdrawExcessAlgo()void ABI method.
   *
   * Withdraw excess ALGO from contract
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  withdrawExcessAlgo(params?: CallParams<AlgoStakeXArgs['obj']['withdrawExcessAlgo()void'] | AlgoStakeXArgs['tuple']['withdrawExcessAlgo()void']>): AlgoStakeXComposer<[...TReturns, AlgoStakeXReturns['withdrawExcessAlgo()void'] | undefined]>

  /**
   * Makes a clear_state call to an existing instance of the AlgoStakeX smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(params?: AppClientBareCallParams): AlgoStakeXComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn A transaction to add to the transaction group
   * @param signer The optional signer to use when signing this transaction.
   */
  addTransaction(txn: Transaction, signer?: TransactionSigner): AlgoStakeXComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  composer(): Promise<TransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(): Promise<AlgoStakeXComposerResults<TReturns> & { simulateResponse: modelsv2.SimulateResponse }>
  simulate(options: SkipSignaturesSimulateOptions): Promise<AlgoStakeXComposerResults<TReturns> & { simulateResponse: modelsv2.SimulateResponse }>
  simulate(options: RawSimulateOptions): Promise<AlgoStakeXComposerResults<TReturns> & { simulateResponse: modelsv2.SimulateResponse }>
  /**
   * Sends the transaction group to the network and returns the results
   */
  send(params?: SendParams): Promise<AlgoStakeXComposerResults<TReturns>>
}
export type AlgoStakeXComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
  returns: TReturns
}>

