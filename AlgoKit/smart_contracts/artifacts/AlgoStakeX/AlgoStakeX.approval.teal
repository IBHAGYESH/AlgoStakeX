#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 8 1 2
    bytecblock 0x00015f "stake_" 0x151f7c750020 0x0055 0x151f7c75
    // smart_contracts/AlgoStakeX/contract.algo.ts:36
    // export class AlgoStakeX extends Contract {
    txn NumAppArgs
    bz main___algots__.defaultCreate@16
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0xa5082119 0xf5d8a34b 0xea00bfff 0x91ae291e 0xef723c8d 0x8d8fdac2 0x772b5574 0x55d9525b 0x30676978 // method "stake(string,uint64,bool,uint64,uint64,string,uint64,string)byte[]", method "withdraw(string)byte[]", method "emergencyWithdraw(string,uint64,address)byte[]", method "hasValidStake(string,string,uint64)bool", method "getStakeInfo(string,string)(address,uint64,bool,uint64,uint64,uint64,uint64,string,uint64,string)", method "donateTokens(uint64,uint64)byte[]", method "withdrawExcessTokens(uint64,uint64)byte[]", method "fundContract(uint64)void", method "withdrawExcessAlgo()void"
    txna ApplicationArgs 0
    match stake withdraw emergencyWithdraw hasValidStake getStakeInfo donateTokens withdrawExcessTokens fundContract withdrawExcessAlgo
    err

main___algots__.defaultCreate@16:
    // smart_contracts/AlgoStakeX/contract.algo.ts:36
    // export class AlgoStakeX extends Contract {
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert // OnCompletion must be NoOp && can only call when creating
    intc_2 // 1
    return


// smart_contracts/AlgoStakeX/contract.algo.ts::AlgoStakeX.stake[routing]() -> void:
stake:
    // smart_contracts/AlgoStakeX/contract.algo.ts:46
    // @abimethod()
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 3
    dup
    cover 3
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for arc4.bool
    txna ApplicationArgs 4
    dup
    cover 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    cover 2
    txna ApplicationArgs 5
    dup
    cover 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    cover 2
    txna ApplicationArgs 6
    dup
    cover 3
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    dup
    cover 5
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    txna ApplicationArgs 7
    dup
    cover 4
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    cover 3
    txna ApplicationArgs 8
    dup
    cover 4
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    // smart_contracts/AlgoStakeX/contract.algo.ts:62
    // op.concat(poolIdBytes, separator),
    uncover 2
    // smart_contracts/AlgoStakeX/contract.algo.ts:60
    // const separator = new arc4.Str("_").bytes;
    bytec_0 // 0x00015f
    // smart_contracts/AlgoStakeX/contract.algo.ts:62
    // op.concat(poolIdBytes, separator),
    concat
    // smart_contracts/AlgoStakeX/contract.algo.ts:63
    // Txn.sender.bytes
    txn Sender
    // smart_contracts/AlgoStakeX/contract.algo.ts:61-64
    // const stakeKey = op.concat(
    //   op.concat(poolIdBytes, separator),
    //   Txn.sender.bytes
    // );
    concat
    cover 2
    // smart_contracts/AlgoStakeX/contract.algo.ts:67-74
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: tokenId,
    //     assetAmount: 0,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/AlgoStakeX/contract.algo.ts:69
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/AlgoStakeX/contract.algo.ts:71
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    uncover 2
    itxn_field XferAsset
    itxn_field AssetReceiver
    // smart_contracts/AlgoStakeX/contract.algo.ts:67-73
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: tokenId,
    //     assetAmount: 0,
    //     fee: 0,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/AlgoStakeX/contract.algo.ts:72
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/AlgoStakeX/contract.algo.ts:67-74
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: tokenId,
    //     assetAmount: 0,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/AlgoStakeX/contract.algo.ts:76
    // const currentTime = Global.latestTimestamp;
    global LatestTimestamp
    swap
    // smart_contracts/AlgoStakeX/contract.algo.ts:80
    // if (rewardType === "APY") {
    pushbytes "APY"
    ==
    bnz stake_after_if_else@5
    // smart_contracts/AlgoStakeX/contract.algo.ts:85
    // rewardRate === Uint64(0),
    dig 3
    !
    // smart_contracts/AlgoStakeX/contract.algo.ts:84-87
    // assert(
    //   rewardRate === Uint64(0),
    //   "rewardRate must be 0 when rewardType is not APY"
    // );
    assert // rewardRate must be 0 when rewardType is not APY

stake_after_if_else@5:
    // smart_contracts/AlgoStakeX/contract.algo.ts:38
    // private stakes = BoxMap<bytes, StakeData>({ keyPrefix: "stake_" });
    bytec_1 // "stake_"
    dig 2
    concat
    dup
    // smart_contracts/AlgoStakeX/contract.algo.ts:91
    // if (this.stakes(stakeKey).exists) {
    box_len
    bury 1
    bz stake_else_body@7
    // smart_contracts/AlgoStakeX/contract.algo.ts:97
    // staker: new arc4.Address(Txn.sender),
    txn Sender
    // smart_contracts/AlgoStakeX/contract.algo.ts:98
    // tokenId: new arc4.Uint64(existingStake.tokenId.asUint64()), // keep original token id
    swap
    dup
    pushint 32 // 32
    intc_1 // 8
    box_extract
    // smart_contracts/AlgoStakeX/contract.algo.ts:101
    // Uint64(existingStake.amount.asUint64() + amount)
    dig 1
    pushint 41 // 41
    intc_1 // 8
    box_extract
    btoi
    dig 13
    +
    // smart_contracts/AlgoStakeX/contract.algo.ts:100-102
    // amount: new arc4.Uint64(
    //   Uint64(existingStake.amount.asUint64() + amount)
    // ), // current amount + new amount
    itob
    // smart_contracts/AlgoStakeX/contract.algo.ts:103
    // stakedAt: new arc4.Uint64(existingStake.stakedAt.asUint64()), // Keep original time
    dig 2
    pushint 49 // 49
    intc_1 // 8
    box_extract
    // smart_contracts/AlgoStakeX/contract.algo.ts:105
    // lockEndTime: new arc4.Uint64(Uint64(currentTime + lockPeriod)), // current lock end time
    dig 5
    dig 13
    +
    itob
    // smart_contracts/AlgoStakeX/contract.algo.ts:96-109
    // const updatedStake = new StakeData({
    //   staker: new arc4.Address(Txn.sender),
    //   tokenId: new arc4.Uint64(existingStake.tokenId.asUint64()), // keep original token id
    //   isFlexible: new arc4.Bool(isFlexible), // current staking type
    //   amount: new arc4.Uint64(
    //     Uint64(existingStake.amount.asUint64() + amount)
    //   ), // current amount + new amount
    //   stakedAt: new arc4.Uint64(existingStake.stakedAt.asUint64()), // Keep original time
    //   lockPeriod: new arc4.Uint64(lockPeriod), // current lock period
    //   lockEndTime: new arc4.Uint64(Uint64(currentTime + lockPeriod)), // current lock end time
    //   rewardType: new arc4.Str(rewardType), // current reward type
    //   rewardRate: new arc4.Uint64(rewardRate), // current reward rate
    //   utility: new arc4.Str(utility), // current utility
    // });
    uncover 5
    uncover 4
    concat
    dig 16
    concat
    uncover 3
    concat
    uncover 2
    concat
    dig 11
    concat
    swap
    concat
    bytec_3 // 0x0055
    concat
    pushint 85 // 85
    dig 8
    +
    swap
    dig 7
    concat
    swap
    itob
    extract 6 2
    concat
    dig 8
    concat
    dig 4
    concat
    // smart_contracts/AlgoStakeX/contract.algo.ts:111
    // this.stakes(stakeKey).value = clone(updatedStake);
    dig 1
    box_del
    pop
    box_put

stake_after_if_else@8:
    // smart_contracts/AlgoStakeX/contract.algo.ts:46
    // @abimethod()
    bytec_2 // 0x151f7c750020
    // smart_contracts/AlgoStakeX/contract.algo.ts:130
    // return Txn.txId;
    txn TxID
    // smart_contracts/AlgoStakeX/contract.algo.ts:46
    // @abimethod()
    concat
    log
    intc_2 // 1
    return

stake_else_body@7:
    // smart_contracts/AlgoStakeX/contract.algo.ts:115
    // staker: new arc4.Address(Txn.sender),
    txn Sender
    // smart_contracts/AlgoStakeX/contract.algo.ts:119
    // stakedAt: new arc4.Uint64(currentTime),
    dig 2
    dup
    itob
    // smart_contracts/AlgoStakeX/contract.algo.ts:121
    // lockEndTime: new arc4.Uint64(Uint64(currentTime + lockPeriod)),
    swap
    dig 11
    +
    itob
    // smart_contracts/AlgoStakeX/contract.algo.ts:114-125
    // const newStake = new StakeData({
    //   staker: new arc4.Address(Txn.sender),
    //   tokenId: new arc4.Uint64(tokenId),
    //   isFlexible: new arc4.Bool(isFlexible),
    //   amount: new arc4.Uint64(amount),
    //   stakedAt: new arc4.Uint64(currentTime),
    //   lockPeriod: new arc4.Uint64(lockPeriod),
    //   lockEndTime: new arc4.Uint64(Uint64(currentTime + lockPeriod)),
    //   rewardType: new arc4.Str(rewardType),
    //   rewardRate: new arc4.Uint64(rewardRate),
    //   utility: new arc4.Str(utility),
    // });
    uncover 2
    dig 16
    concat
    dig 15
    concat
    dig 14
    concat
    uncover 2
    concat
    dig 11
    concat
    swap
    concat
    bytec_3 // 0x0055
    concat
    pushint 85 // 85
    dig 8
    +
    swap
    dig 7
    concat
    swap
    itob
    extract 6 2
    concat
    dig 8
    concat
    dig 4
    concat
    // smart_contracts/AlgoStakeX/contract.algo.ts:127
    // this.stakes(stakeKey).value = clone(newStake);
    swap
    dup
    box_del
    pop
    swap
    box_put
    b stake_after_if_else@8


// smart_contracts/AlgoStakeX/contract.algo.ts::AlgoStakeX.withdraw[routing]() -> void:
withdraw:
    // smart_contracts/AlgoStakeX/contract.algo.ts:136
    // @abimethod()
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    // smart_contracts/AlgoStakeX/contract.algo.ts:140
    // const separator = new arc4.Str("_").bytes;
    bytec_0 // 0x00015f
    // smart_contracts/AlgoStakeX/contract.algo.ts:142
    // op.concat(poolIdBytes, separator),
    concat
    // smart_contracts/AlgoStakeX/contract.algo.ts:143
    // Txn.sender.bytes
    txn Sender
    // smart_contracts/AlgoStakeX/contract.algo.ts:141-144
    // const stakeKey = op.concat(
    //   op.concat(poolIdBytes, separator),
    //   Txn.sender.bytes
    // );
    concat
    // smart_contracts/AlgoStakeX/contract.algo.ts:38
    // private stakes = BoxMap<bytes, StakeData>({ keyPrefix: "stake_" });
    bytec_1 // "stake_"
    swap
    concat
    dupn 2
    // smart_contracts/AlgoStakeX/contract.algo.ts:147
    // assert(this.stakes(stakeKey).exists, "No active stake found");
    box_len
    bury 1
    assert // No active stake found
    // smart_contracts/AlgoStakeX/contract.algo.ts:152
    // const currentSenderAddr = new arc4.Address(Txn.sender);
    txn Sender
    // smart_contracts/AlgoStakeX/contract.algo.ts:154
    // stakeData.staker.native === currentSenderAddr.native,
    dig 1
    intc_0 // 0
    pushint 32 // 32
    box_extract
    ==
    // smart_contracts/AlgoStakeX/contract.algo.ts:153-156
    // assert(
    //   stakeData.staker.native === currentSenderAddr.native,
    //   "Not the staker"
    // );
    assert // Not the staker
    // smart_contracts/AlgoStakeX/contract.algo.ts:158
    // const currentTime = Global.latestTimestamp;
    global LatestTimestamp
    swap
    // smart_contracts/AlgoStakeX/contract.algo.ts:161
    // if (!stakeData.isFlexible.native) {
    pushint 40 // 40
    intc_2 // 1
    box_extract
    intc_0 // 0
    getbit
    pushbytes 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    bnz withdraw_after_if_else@3
    // smart_contracts/AlgoStakeX/contract.algo.ts:163
    // currentTime >= stakeData.lockEndTime.asUint64(),
    dig 1
    pushint 65 // 65
    intc_1 // 8
    box_extract
    btoi
    dig 1
    <=
    // smart_contracts/AlgoStakeX/contract.algo.ts:162-165
    // assert(
    //   currentTime >= stakeData.lockEndTime.asUint64(),
    //   "Lock period not ended"
    // );
    assert // Lock period not ended

withdraw_after_if_else@3:
    // smart_contracts/AlgoStakeX/contract.algo.ts:169-176
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     xferAsset: stakeData.tokenId.asUint64(),
    //     assetAmount: stakeData.amount.asUint64(),
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/AlgoStakeX/contract.algo.ts:171
    // assetReceiver: Txn.sender,
    txn Sender
    // smart_contracts/AlgoStakeX/contract.algo.ts:172
    // xferAsset: stakeData.tokenId.asUint64(),
    dig 2
    dup
    pushint 32 // 32
    intc_1 // 8
    box_extract
    btoi
    // smart_contracts/AlgoStakeX/contract.algo.ts:173
    // assetAmount: stakeData.amount.asUint64(),
    dig 1
    pushint 41 // 41
    intc_1 // 8
    box_extract
    btoi
    itxn_field AssetAmount
    itxn_field XferAsset
    swap
    itxn_field AssetReceiver
    // smart_contracts/AlgoStakeX/contract.algo.ts:169-175
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     xferAsset: stakeData.tokenId.asUint64(),
    //     assetAmount: stakeData.amount.asUint64(),
    //     fee: 0,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/AlgoStakeX/contract.algo.ts:174
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/AlgoStakeX/contract.algo.ts:169-176
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     xferAsset: stakeData.tokenId.asUint64(),
    //     assetAmount: stakeData.amount.asUint64(),
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/AlgoStakeX/contract.algo.ts:182
    // this.stakes(stakeKey).delete();
    box_del
    pop
    // smart_contracts/AlgoStakeX/contract.algo.ts:136
    // @abimethod()
    bytec_2 // 0x151f7c750020
    // smart_contracts/AlgoStakeX/contract.algo.ts:184
    // return Txn.txId;
    txn TxID
    // smart_contracts/AlgoStakeX/contract.algo.ts:136
    // @abimethod()
    concat
    log
    intc_2 // 1
    return


// smart_contracts/AlgoStakeX/contract.algo.ts::AlgoStakeX.emergencyWithdraw[routing]() -> void:
emergencyWithdraw:
    // smart_contracts/AlgoStakeX/contract.algo.ts:191
    // @abimethod()
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 3
    dup
    cover 3
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/AlgoStakeX/contract.algo.ts:200
    // op.concat(poolIdBytes, separator),
    swap
    // smart_contracts/AlgoStakeX/contract.algo.ts:198
    // const separator = new arc4.Str("_").bytes;
    bytec_0 // 0x00015f
    // smart_contracts/AlgoStakeX/contract.algo.ts:200
    // op.concat(poolIdBytes, separator),
    concat
    // smart_contracts/AlgoStakeX/contract.algo.ts:201
    // Txn.sender.bytes
    txn Sender
    // smart_contracts/AlgoStakeX/contract.algo.ts:199-202
    // const stakeKey = op.concat(
    //   op.concat(poolIdBytes, separator),
    //   Txn.sender.bytes
    // );
    concat
    // smart_contracts/AlgoStakeX/contract.algo.ts:38
    // private stakes = BoxMap<bytes, StakeData>({ keyPrefix: "stake_" });
    bytec_1 // "stake_"
    swap
    concat
    dup
    cover 2
    // smart_contracts/AlgoStakeX/contract.algo.ts:204
    // assert(this.stakes(stakeKey).exists, "No active stake found");
    dup
    box_len
    bury 1
    assert // No active stake found
    // smart_contracts/AlgoStakeX/contract.algo.ts:208
    // const currentSenderAddr = new arc4.Address(Txn.sender);
    txn Sender
    // smart_contracts/AlgoStakeX/contract.algo.ts:210
    // stakeData.staker.native === currentSenderAddr.native,
    dig 1
    intc_0 // 0
    pushint 32 // 32
    box_extract
    ==
    // smart_contracts/AlgoStakeX/contract.algo.ts:209-212
    // assert(
    //   stakeData.staker.native === currentSenderAddr.native,
    //   "Not the staker"
    // );
    assert // Not the staker
    // smart_contracts/AlgoStakeX/contract.algo.ts:216
    // (stakeData.amount.asUint64() * penaltyPercentage) / BASIS_POINTS_DIVISOR
    dup
    pushint 41 // 41
    intc_1 // 8
    box_extract
    btoi
    dup
    uncover 3
    *
    pushint 10000 // 10000
    /
    dup
    cover 3
    // smart_contracts/AlgoStakeX/contract.algo.ts:218
    // const amountToReturn = Uint64(stakeData.amount.asUint64() - penalty);
    swap
    dig 1
    -
    // smart_contracts/AlgoStakeX/contract.algo.ts:221-228
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     xferAsset: stakeData.tokenId.asUint64(),
    //     assetAmount: amountToReturn,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/AlgoStakeX/contract.algo.ts:223
    // assetReceiver: Txn.sender,
    txn Sender
    // smart_contracts/AlgoStakeX/contract.algo.ts:224
    // xferAsset: stakeData.tokenId.asUint64(),
    uncover 3
    pushint 32 // 32
    intc_1 // 8
    box_extract
    btoi
    dup
    cover 4
    uncover 2
    itxn_field AssetAmount
    itxn_field XferAsset
    itxn_field AssetReceiver
    // smart_contracts/AlgoStakeX/contract.algo.ts:221-227
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     xferAsset: stakeData.tokenId.asUint64(),
    //     assetAmount: amountToReturn,
    //     fee: 0,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/AlgoStakeX/contract.algo.ts:226
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/AlgoStakeX/contract.algo.ts:221-228
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     xferAsset: stakeData.tokenId.asUint64(),
    //     assetAmount: amountToReturn,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/AlgoStakeX/contract.algo.ts:231
    // if (penalty > 0) {
    bz emergencyWithdraw_after_if_else@5
    // smart_contracts/AlgoStakeX/contract.algo.ts:232-239
    // itxn
    //   .assetTransfer({
    //     assetReceiver: treasuryAddress.native,
    //     xferAsset: stakeData.tokenId.asUint64(),
    //     assetAmount: penalty,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    dig 1
    itxn_field AssetAmount
    dup
    itxn_field XferAsset
    dig 3
    itxn_field AssetReceiver
    // smart_contracts/AlgoStakeX/contract.algo.ts:232-238
    // itxn
    //   .assetTransfer({
    //     assetReceiver: treasuryAddress.native,
    //     xferAsset: stakeData.tokenId.asUint64(),
    //     assetAmount: penalty,
    //     fee: 0,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/AlgoStakeX/contract.algo.ts:237
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/AlgoStakeX/contract.algo.ts:232-239
    // itxn
    //   .assetTransfer({
    //     assetReceiver: treasuryAddress.native,
    //     xferAsset: stakeData.tokenId.asUint64(),
    //     assetAmount: penalty,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit

emergencyWithdraw_after_if_else@5:
    // smart_contracts/AlgoStakeX/contract.algo.ts:243
    // this.stakes(stakeKey).delete();
    dig 2
    box_del
    pop
    // smart_contracts/AlgoStakeX/contract.algo.ts:191
    // @abimethod()
    bytec_2 // 0x151f7c750020
    // smart_contracts/AlgoStakeX/contract.algo.ts:245
    // return Txn.txId;
    txn TxID
    // smart_contracts/AlgoStakeX/contract.algo.ts:191
    // @abimethod()
    concat
    log
    intc_2 // 1
    return


// smart_contracts/AlgoStakeX/contract.algo.ts::AlgoStakeX.hasValidStake[routing]() -> void:
hasValidStake:
    // smart_contracts/AlgoStakeX/contract.algo.ts:251
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    cover 2
    // smart_contracts/AlgoStakeX/contract.algo.ts:262
    // op.concat(poolIdBytes, separator),
    swap
    // smart_contracts/AlgoStakeX/contract.algo.ts:259
    // const separator = new arc4.Str("_").bytes;
    bytec_0 // 0x00015f
    // smart_contracts/AlgoStakeX/contract.algo.ts:262
    // op.concat(poolIdBytes, separator),
    concat
    // smart_contracts/AlgoStakeX/contract.algo.ts:261-264
    // const stakeKey = op.concat(
    //   op.concat(poolIdBytes, separator),
    //   userAddrBytes
    // );
    swap
    concat
    // smart_contracts/AlgoStakeX/contract.algo.ts:38
    // private stakes = BoxMap<bytes, StakeData>({ keyPrefix: "stake_" });
    bytec_1 // "stake_"
    swap
    concat
    dup
    // smart_contracts/AlgoStakeX/contract.algo.ts:266
    // if (!this.stakes(stakeKey).exists) {
    box_len
    bury 1
    bnz hasValidStake_after_if_else@3
    // smart_contracts/AlgoStakeX/contract.algo.ts:267
    // return false;
    intc_0 // 0

hasValidStake_after_inlined_smart_contracts/AlgoStakeX/contract.algo.ts::AlgoStakeX.hasValidStake@6:
    // smart_contracts/AlgoStakeX/contract.algo.ts:251
    // @abimethod({ readonly: true })
    pushbytes 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

hasValidStake_after_if_else@3:
    // smart_contracts/AlgoStakeX/contract.algo.ts:273
    // if (stakeData.amount.asUint64() < minimumAmount) {
    dup
    pushint 41 // 41
    intc_1 // 8
    box_extract
    btoi
    dig 2
    <
    bz hasValidStake_after_if_else@5
    // smart_contracts/AlgoStakeX/contract.algo.ts:274
    // return false;
    intc_0 // 0
    // smart_contracts/AlgoStakeX/contract.algo.ts:251
    // @abimethod({ readonly: true })
    b hasValidStake_after_inlined_smart_contracts/AlgoStakeX/contract.algo.ts::AlgoStakeX.hasValidStake@6

hasValidStake_after_if_else@5:
    // smart_contracts/AlgoStakeX/contract.algo.ts:277
    // return true;
    intc_2 // 1
    // smart_contracts/AlgoStakeX/contract.algo.ts:251
    // @abimethod({ readonly: true })
    b hasValidStake_after_inlined_smart_contracts/AlgoStakeX/contract.algo.ts::AlgoStakeX.hasValidStake@6


// smart_contracts/AlgoStakeX/contract.algo.ts::AlgoStakeX.getStakeInfo[routing]() -> void:
getStakeInfo:
    // smart_contracts/AlgoStakeX/contract.algo.ts:283
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    // smart_contracts/AlgoStakeX/contract.algo.ts:289
    // op.concat(poolIdBytes, separator),
    swap
    // smart_contracts/AlgoStakeX/contract.algo.ts:286
    // const separator = new arc4.Str("_").bytes;
    bytec_0 // 0x00015f
    // smart_contracts/AlgoStakeX/contract.algo.ts:289
    // op.concat(poolIdBytes, separator),
    concat
    // smart_contracts/AlgoStakeX/contract.algo.ts:288-291
    // const stakeKey = op.concat(
    //   op.concat(poolIdBytes, separator),
    //   userAddrBytes
    // );
    swap
    concat
    // smart_contracts/AlgoStakeX/contract.algo.ts:38
    // private stakes = BoxMap<bytes, StakeData>({ keyPrefix: "stake_" });
    bytec_1 // "stake_"
    swap
    concat
    // smart_contracts/AlgoStakeX/contract.algo.ts:293
    // assert(this.stakes(stakeKey).exists, "No stake found");
    dup
    box_len
    bury 1
    assert // No stake found
    // smart_contracts/AlgoStakeX/contract.algo.ts:295
    // return clone(this.stakes(stakeKey).value);
    box_get
    pop
    // smart_contracts/AlgoStakeX/contract.algo.ts:283
    // @abimethod({ readonly: true })
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return


// smart_contracts/AlgoStakeX/contract.algo.ts::AlgoStakeX.donateTokens[routing]() -> void:
donateTokens:
    // smart_contracts/AlgoStakeX/contract.algo.ts:400
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/AlgoStakeX/contract.algo.ts:403-410
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: tokenId,
    //     assetAmount: 0,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/AlgoStakeX/contract.algo.ts:405
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/AlgoStakeX/contract.algo.ts:407
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/AlgoStakeX/contract.algo.ts:403-409
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: tokenId,
    //     assetAmount: 0,
    //     fee: 0,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/AlgoStakeX/contract.algo.ts:408
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/AlgoStakeX/contract.algo.ts:403-410
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     xferAsset: tokenId,
    //     assetAmount: 0,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/AlgoStakeX/contract.algo.ts:400
    // @abimethod()
    bytec_2 // 0x151f7c750020
    // smart_contracts/AlgoStakeX/contract.algo.ts:412
    // return Txn.txId;
    txn TxID
    // smart_contracts/AlgoStakeX/contract.algo.ts:400
    // @abimethod()
    concat
    log
    intc_2 // 1
    return


// smart_contracts/AlgoStakeX/contract.algo.ts::AlgoStakeX.withdrawExcessTokens[routing]() -> void:
withdrawExcessTokens:
    // smart_contracts/AlgoStakeX/contract.algo.ts:419
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/AlgoStakeX/contract.algo.ts:423
    // Txn.sender === Global.creatorAddress,
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/AlgoStakeX/contract.algo.ts:422-425
    // assert(
    //   Txn.sender === Global.creatorAddress,
    //   "Only admin can withdraw excess"
    // );
    assert // Only admin can withdraw excess
    // smart_contracts/AlgoStakeX/contract.algo.ts:429-436
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     xferAsset: tokenId,
    //     assetAmount: amount,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/AlgoStakeX/contract.algo.ts:431
    // assetReceiver: Txn.sender,
    txn Sender
    itxn_field AssetReceiver
    itxn_field AssetAmount
    itxn_field XferAsset
    // smart_contracts/AlgoStakeX/contract.algo.ts:429-435
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     xferAsset: tokenId,
    //     assetAmount: amount,
    //     fee: 0,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/AlgoStakeX/contract.algo.ts:434
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/AlgoStakeX/contract.algo.ts:429-436
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     xferAsset: tokenId,
    //     assetAmount: amount,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/AlgoStakeX/contract.algo.ts:419
    // @abimethod()
    bytec_2 // 0x151f7c750020
    // smart_contracts/AlgoStakeX/contract.algo.ts:438
    // return Txn.txId;
    txn TxID
    // smart_contracts/AlgoStakeX/contract.algo.ts:419
    // @abimethod()
    concat
    log
    intc_2 // 1
    return


// smart_contracts/AlgoStakeX/contract.algo.ts::AlgoStakeX.fundContract[routing]() -> void:
fundContract:
    // smart_contracts/AlgoStakeX/contract.algo.ts:444
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/AlgoStakeX/contract.algo.ts:447
    // Txn.sender === Global.creatorAddress,
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/AlgoStakeX/contract.algo.ts:446-449
    // assert(
    //   Txn.sender === Global.creatorAddress,
    //   "Only admin can fund the contract"
    // );
    assert // Only admin can fund the contract
    // smart_contracts/AlgoStakeX/contract.algo.ts:451-457
    // itxn
    //   .payment({
    //     amount: amount,
    //     receiver: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/AlgoStakeX/contract.algo.ts:454
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/AlgoStakeX/contract.algo.ts:451-456
    // itxn
    //   .payment({
    //     amount: amount,
    //     receiver: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    intc_2 // 1
    itxn_field TypeEnum
    // smart_contracts/AlgoStakeX/contract.algo.ts:455
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/AlgoStakeX/contract.algo.ts:451-457
    // itxn
    //   .payment({
    //     amount: amount,
    //     receiver: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/AlgoStakeX/contract.algo.ts:444
    // @abimethod()
    intc_2 // 1
    return


// smart_contracts/AlgoStakeX/contract.algo.ts::AlgoStakeX.withdrawExcessAlgo[routing]() -> void:
withdrawExcessAlgo:
    // smart_contracts/AlgoStakeX/contract.algo.ts:466
    // Txn.sender === Global.creatorAddress,
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/AlgoStakeX/contract.algo.ts:465-468
    // assert(
    //   Txn.sender === Global.creatorAddress,
    //   "Only admin can withdraw funds"
    // );
    assert // Only admin can withdraw funds
    // smart_contracts/AlgoStakeX/contract.algo.ts:471
    // Global.currentApplicationAddress.balance - MIN_BALANCE
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    pushint 100000 // 100000
    -
    // smart_contracts/AlgoStakeX/contract.algo.ts:474
    // assert(amountToWithdraw > Uint64(0), "No excess balance to withdraw");
    dup
    assert // No excess balance to withdraw
    // smart_contracts/AlgoStakeX/contract.algo.ts:476-482
    // itxn
    //   .payment({
    //     amount: amountToWithdraw,
    //     receiver: Txn.sender,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/AlgoStakeX/contract.algo.ts:479
    // receiver: Txn.sender,
    txn Sender
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/AlgoStakeX/contract.algo.ts:476-481
    // itxn
    //   .payment({
    //     amount: amountToWithdraw,
    //     receiver: Txn.sender,
    //     fee: 0,
    //   })
    intc_2 // 1
    itxn_field TypeEnum
    // smart_contracts/AlgoStakeX/contract.algo.ts:480
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/AlgoStakeX/contract.algo.ts:476-482
    // itxn
    //   .payment({
    //     amount: amountToWithdraw,
    //     receiver: Txn.sender,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/AlgoStakeX/contract.algo.ts:463
    // @abimethod()
    intc_2 // 1
    return
